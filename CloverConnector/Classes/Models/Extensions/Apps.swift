
/**
 * Autogenerated by Avro
 *
 * DO NOT EDIT DIRECTLY
 */

import ObjectMapper

extension CLVModels {
  public class Apps {
    
    
    @objc(_TtCCC15CloverConnector9CLVModels4Apps17AndroidPermission)public class AndroidPermission: NSObject, NSCoding, Mappable {
      /// Unique identifier
      public var id: String?
      public var permission: String?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(id, forKey: "id")
        aCoder.encode(permission, forKey: "permission")
      }
      
      required public init(coder aDecoder: NSCoder) {
        id = aDecoder.decodeObject(forKey: "id") as? String
        permission = aDecoder.decodeObject(forKey: "permission") as? String
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        id <- map["id"]
        permission <- map["permission"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels4Apps14AndroidVersion)public class AndroidVersion: NSObject, NSCoding, Mappable {
      public var id: String?
      /// Creation timestamp
      public var createdAt: Int?
      /// Unique identifier
      public var version_: Int?
      public var versionName: String?
      public var approved: Bool?
      public var hash_: String?
      public var deviceInstallCount: Int?
      public var hashOriginal: String?
      public var approvalStatus: CLVModels.Base.ApprovalStatus? = nil
      /// VirusTotal scan status
      public var scanStatus: CLVModels.Apps.ScanStatus? = nil
      /// VirusTotal scan_id field, which is the sha256 hash joined with the timestamp by a hyphen
      public var scanId: String?
      /// The minSdkVersion attribute parsed from the AndroidManifest.xml
      public var minSdkVersion: Int?
      /// The message digest algorithm used to digest the entries of the APK
      public var digestAlg: String?
      /// Url to download the APK
      public var apkUrl: String?
      /// List of android permissions
      public var permissions: [String]?
      /// Reference to the app this Android version belongs to
      public var app: CLVModels.Apps.App?
      /// Reference to the release note for this Android Version
      public var releaseNote: CLVModels.Base.Reference?
      /// The merchant groups that the Android version belongs to
      public var merchantGroups: [CLVModels.Developer.MerchantGroup]?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(id, forKey: "id")
        aCoder.encode(createdAt, forKey: "createdAt")
        aCoder.encode(version_, forKey: "version_")
        aCoder.encode(versionName, forKey: "versionName")
        aCoder.encode(approved, forKey: "approved")
        aCoder.encode(hash_, forKey: "hash_")
        aCoder.encode(deviceInstallCount, forKey: "deviceInstallCount")
        aCoder.encode(hashOriginal, forKey: "hashOriginal")
        aCoder.encode(approvalStatus?.rawValue, forKey: "approvalStatus")
        aCoder.encode(scanStatus?.rawValue, forKey: "scanStatus")
        aCoder.encode(scanId, forKey: "scanId")
        aCoder.encode(minSdkVersion, forKey: "minSdkVersion")
        aCoder.encode(digestAlg, forKey: "digestAlg")
        aCoder.encode(apkUrl, forKey: "apkUrl")
        aCoder.encode(permissions, forKey: "permissions")
        aCoder.encode(app, forKey: "app")
        aCoder.encode(releaseNote, forKey: "releaseNote")
        aCoder.encode(merchantGroups, forKey: "merchantGroups")
      }
      
      required public init(coder aDecoder: NSCoder) {
        id = aDecoder.decodeObject(forKey: "id") as? String
        createdAt = aDecoder.decodeObject(forKey: "createdAt") as? Int
        version_ = aDecoder.decodeObject(forKey: "version_") as? Int
        versionName = aDecoder.decodeObject(forKey: "versionName") as? String
        approved = aDecoder.decodeObject(forKey: "approved") as? Bool
        hash_ = aDecoder.decodeObject(forKey: "hash_") as? String
        deviceInstallCount = aDecoder.decodeObject(forKey: "deviceInstallCount") as? Int
        hashOriginal = aDecoder.decodeObject(forKey: "hashOriginal") as? String
        if let approvalStatusString = (aDecoder.decodeObject(forKey: "approvalStatus") as? String) {
            approvalStatus =  CLVModels.Base.ApprovalStatus(rawValue: approvalStatusString)
        }
        if let scanStatusString = (aDecoder.decodeObject(forKey: "scanStatus") as? String) {
            scanStatus = CLVModels.Apps.ScanStatus(rawValue: scanStatusString)
        }
        scanId = aDecoder.decodeObject(forKey: "scanId") as? String
        minSdkVersion = aDecoder.decodeObject(forKey: "minSdkVersion") as? Int
        digestAlg = aDecoder.decodeObject(forKey: "digestAlg") as? String
        apkUrl = aDecoder.decodeObject(forKey: "apkUrl") as? String
        permissions = aDecoder.decodeObject(forKey: "permissions") as? [String]
        app = aDecoder.decodeObject(forKey: "app") as? CLVModels.Apps.App
        releaseNote = aDecoder.decodeObject(forKey: "releaseNote") as? CLVModels.Base.Reference
        merchantGroups = aDecoder.decodeObject(forKey: "merchantGroups") as? [CLVModels.Developer.MerchantGroup]
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        id <- map["id"]
        createdAt <- map["createdAt"]
        version_ <- map["version"]
        versionName <- map["versionName"]
        approved <- map["approved"]
        hash_ <- map["hash"]
        deviceInstallCount <- map["deviceInstallCount"]
        hashOriginal <- map["hashOriginal"]
        approvalStatus <- map["approvalStatus"]
        scanStatus <- map["scanStatus"]
        scanId <- map["scanId"]
        minSdkVersion <- map["minSdkVersion"]
        digestAlg <- map["digestAlg"]
        apkUrl <- map["apkUrl"]
        permissions <- map["permissions"]
        app <- map["app"]
        releaseNote <- map["releaseNote"]
        merchantGroups <- map["merchantGroups.elements"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels4Apps3App)public class App: NSObject, NSCoding, Mappable {
      public var id: String?
      /// Name of the app
      public var name: String?
      public var published: Bool?
      public var developer: CLVModels.Developer.Developer?
      /// Only available when app is installed to a merchant
      public var merchant: CLVModels.Merchant.Merchant?
      /// App Description
      public var description_: String?
      /// Short tagline for the app
      public var tagline: String?
      /// URL for embedded video
      public var videoUrl: String?
      /// Activation url for redirecting users after app installation.
      public var activationUrl: String?
      /// Site url for oauth redirect and web app launch from appmarket.
      public var siteUrl: String?
      /// Default oauth response type.
      public var defaultResponseType: CLVModels.Apps.OAuthResponseType? = nil
      public var appDomain: String?
      public var androidVersion: CLVModels.Apps.AndroidVersion?
      public var packageName: String?
      public var approved: Bool?
      public var systemApp: Bool?
      public var hidden: Bool?
      public var filenameIcon: String?
      /// URL to the icon of the app. Generated from filenameIcon.
      public var filenameIconSmall: String?
      /// URL to the icon of the app. Generated from filenameIcon.
      public var filenameIconLarge: String?
      public var installCount: Int?
      public var sortOrder: Int?
      public var permissionMerchantRead: Bool?
      public var permissionMerchantWrite: Bool?
      public var permissionCustomersRead: Bool?
      public var permissionCustomersWrite: Bool?
      public var permissionInventoryRead: Bool?
      public var permissionInventoryWrite: Bool?
      public var permissionOrdersRead: Bool?
      public var permissionOrdersWrite: Bool?
      public var permissionPaymentsRead: Bool?
      public var permissionPaymentsWrite: Bool?
      public var permissionEmployeesRead: Bool?
      public var permissionEmployeesWrite: Bool?
      public var permissionProcessCards: Bool?
      public var permissionMidRead: Bool?
      public var privacyPolicy: String?
      public var eula: String?
      public var supportPhone: String?
      public var supportPhoneHours: String?
      public var supportEmail: String?
      public var supportUrl: String?
      public var productType: CLVModels.Apps.ProductType? = nil
      public var approvalStatus: CLVModels.Base.ApprovalStatus? = nil
      /// The app's android permissions
      public var androidPermissions: [CLVModels.Apps.AndroidPermission]?
      /// The app's screenshots
      public var screenshots: [CLVModels.Apps.Screenshot]?
      /// Available subscription options for this app
      public var availableSubscriptions: [CLVModels.Apps.AppSubscription]?
      /// Subscription options for this app
      public var subscriptions: [CLVModels.Apps.AppSubscription]?
      /// Available metered options for this app
      public var availableMetereds: [CLVModels.Apps.AppMetered]?
      /// Metered options for this app
      public var metereds: [CLVModels.Apps.AppMetered]?
      /// USB devices with which this app will communicate
      public var usbDevices: [CLVModels.Apps.AppUsbDevice]?
      /// The merchant's current subscription for this app
      public var currentSubscription: CLVModels.Apps.AppSubscription?
      /// The app's web hook
      public var webhook: CLVModels.Apps.WebHook?
      /// The app's uploaded apks
      public var androidVersions: [CLVModels.Apps.AndroidVersion]?
      ///  Whether the app is installed 
      public var installed: Bool?
      /// If the merchant has the app installed, this is the timestamp of when they installed the app.
      public var installedTime: Date?
      /// If the app is a paid app, this tells whether it currently offers a 30 day free trial or not.  Developer can toggle at will.
      public var paidAppHasTrial: Bool?
      /// Records the time that the approval status last changed
      public var approvalStatusModifiedTime: Date?
      /// Text will print on printed receipts for this app
      public var smartReceiptText: String?
      /// URL we will expose on printed and web receipts for this app
      public var smartReceiptUrl: String?
      /// If the merchant has the app installed, this is the timestamp of when they start/started paying.  If the merchant doesn't have the app installed, this is the timestamp of when they would start paying.  In UTC.  Applies to paid apps only.
      public var billingStartTime: Date?
      /// App's client secret for use with oauth
      public var appSecret: String?
      /// App's associated business types
      public var businessTypes: [CLVModels.Apps.BusinessType]?
      /// App's supported device types
      public var deviceTypes: [CLVModels.Apps.DeviceType]?
      public var modules: [CLVModels.Merchant.Module]?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(id, forKey: "id")
        aCoder.encode(name, forKey: "name")
        aCoder.encode(published, forKey: "published")
        aCoder.encode(developer, forKey: "developer")
        aCoder.encode(merchant, forKey: "merchant")
        aCoder.encode(description_, forKey: "description_")
        aCoder.encode(tagline, forKey: "tagline")
        aCoder.encode(videoUrl, forKey: "videoUrl")
        aCoder.encode(activationUrl, forKey: "activationUrl")
        aCoder.encode(siteUrl, forKey: "siteUrl")
        aCoder.encode(defaultResponseType?.rawValue, forKey: "defaultResponseType")
        aCoder.encode(appDomain, forKey: "appDomain")
        aCoder.encode(androidVersion, forKey: "androidVersion")
        aCoder.encode(packageName, forKey: "packageName")
        aCoder.encode(approved, forKey: "approved")
        aCoder.encode(systemApp, forKey: "systemApp")
        aCoder.encode(hidden, forKey: "hidden")
        aCoder.encode(filenameIcon, forKey: "filenameIcon")
        aCoder.encode(filenameIconSmall, forKey: "filenameIconSmall")
        aCoder.encode(filenameIconLarge, forKey: "filenameIconLarge")
        aCoder.encode(installCount, forKey: "installCount")
        aCoder.encode(sortOrder, forKey: "sortOrder")
        aCoder.encode(permissionMerchantRead, forKey: "permissionMerchantRead")
        aCoder.encode(permissionMerchantWrite, forKey: "permissionMerchantWrite")
        aCoder.encode(permissionCustomersRead, forKey: "permissionCustomersRead")
        aCoder.encode(permissionCustomersWrite, forKey: "permissionCustomersWrite")
        aCoder.encode(permissionInventoryRead, forKey: "permissionInventoryRead")
        aCoder.encode(permissionInventoryWrite, forKey: "permissionInventoryWrite")
        aCoder.encode(permissionOrdersRead, forKey: "permissionOrdersRead")
        aCoder.encode(permissionOrdersWrite, forKey: "permissionOrdersWrite")
        aCoder.encode(permissionPaymentsRead, forKey: "permissionPaymentsRead")
        aCoder.encode(permissionPaymentsWrite, forKey: "permissionPaymentsWrite")
        aCoder.encode(permissionEmployeesRead, forKey: "permissionEmployeesRead")
        aCoder.encode(permissionEmployeesWrite, forKey: "permissionEmployeesWrite")
        aCoder.encode(permissionProcessCards, forKey: "permissionProcessCards")
        aCoder.encode(permissionMidRead, forKey: "permissionMidRead")
        aCoder.encode(privacyPolicy, forKey: "privacyPolicy")
        aCoder.encode(eula, forKey: "eula")
        aCoder.encode(supportPhone, forKey: "supportPhone")
        aCoder.encode(supportPhoneHours, forKey: "supportPhoneHours")
        aCoder.encode(supportEmail, forKey: "supportEmail")
        aCoder.encode(supportUrl, forKey: "supportUrl")
        aCoder.encode(productType?.rawValue, forKey: "productType")
        aCoder.encode(approvalStatus?.rawValue, forKey: "approvalStatus")
        aCoder.encode(androidPermissions, forKey: "androidPermissions")
        aCoder.encode(screenshots, forKey: "screenshots")
        aCoder.encode(availableSubscriptions, forKey: "availableSubscriptions")
        aCoder.encode(subscriptions, forKey: "subscriptions")
        aCoder.encode(availableMetereds, forKey: "availableMetereds")
        aCoder.encode(metereds, forKey: "metereds")
        aCoder.encode(usbDevices, forKey: "usbDevices")
        aCoder.encode(currentSubscription, forKey: "currentSubscription")
        aCoder.encode(webhook, forKey: "webhook")
        aCoder.encode(androidVersions, forKey: "androidVersions")
        aCoder.encode(installed, forKey: "installed")
        aCoder.encode(installedTime, forKey: "installedTime")
        aCoder.encode(paidAppHasTrial, forKey: "paidAppHasTrial")
        aCoder.encode(approvalStatusModifiedTime, forKey: "approvalStatusModifiedTime")
        aCoder.encode(smartReceiptText, forKey: "smartReceiptText")
        aCoder.encode(smartReceiptUrl, forKey: "smartReceiptUrl")
        aCoder.encode(billingStartTime, forKey: "billingStartTime")
        aCoder.encode(appSecret, forKey: "appSecret")
        aCoder.encode(businessTypes, forKey: "businessTypes")
        aCoder.encode(deviceTypes, forKey: "deviceTypes")
        aCoder.encode(modules, forKey: "modules")
      }
      
      required public init(coder aDecoder: NSCoder) {
        id = aDecoder.decodeObject(forKey: "id") as? String
        name = aDecoder.decodeObject(forKey: "name") as? String
        published = aDecoder.decodeObject(forKey: "published") as? Bool
        developer = aDecoder.decodeObject(forKey: "developer") as? CLVModels.Developer.Developer
        merchant = aDecoder.decodeObject(forKey: "merchant") as? CLVModels.Merchant.Merchant
        description_ = aDecoder.decodeObject(forKey: "description_") as? String
        tagline = aDecoder.decodeObject(forKey: "tagline") as? String
        videoUrl = aDecoder.decodeObject(forKey: "videoUrl") as? String
        activationUrl = aDecoder.decodeObject(forKey: "activationUrl") as? String
        siteUrl = aDecoder.decodeObject(forKey: "siteUrl") as? String
        if let defaultResponseTypeString = (aDecoder.decodeObject(forKey: "defaultResponseType") as? String) {
            defaultResponseType = CLVModels.Apps.OAuthResponseType(rawValue: defaultResponseTypeString)
        }
        appDomain = aDecoder.decodeObject(forKey: "appDomain") as? String
        androidVersion = aDecoder.decodeObject(forKey: "androidVersion") as? CLVModels.Apps.AndroidVersion
        packageName = aDecoder.decodeObject(forKey: "packageName") as? String
        approved = aDecoder.decodeObject(forKey: "approved") as? Bool
        systemApp = aDecoder.decodeObject(forKey: "systemApp") as? Bool
        hidden = aDecoder.decodeObject(forKey: "hidden") as? Bool
        filenameIcon = aDecoder.decodeObject(forKey: "filenameIcon") as? String
        filenameIconSmall = aDecoder.decodeObject(forKey: "filenameIconSmall") as? String
        filenameIconLarge = aDecoder.decodeObject(forKey: "filenameIconLarge") as? String
        installCount = aDecoder.decodeObject(forKey: "installCount") as? Int
        sortOrder = aDecoder.decodeObject(forKey: "sortOrder") as? Int
        permissionMerchantRead = aDecoder.decodeObject(forKey: "permissionMerchantRead") as? Bool
        permissionMerchantWrite = aDecoder.decodeObject(forKey: "permissionMerchantWrite") as? Bool
        permissionCustomersRead = aDecoder.decodeObject(forKey: "permissionCustomersRead") as? Bool
        permissionCustomersWrite = aDecoder.decodeObject(forKey: "permissionCustomersWrite") as? Bool
        permissionInventoryRead = aDecoder.decodeObject(forKey: "permissionInventoryRead") as? Bool
        permissionInventoryWrite = aDecoder.decodeObject(forKey: "permissionInventoryWrite") as? Bool
        permissionOrdersRead = aDecoder.decodeObject(forKey: "permissionOrdersRead") as? Bool
        permissionOrdersWrite = aDecoder.decodeObject(forKey: "permissionOrdersWrite") as? Bool
        permissionPaymentsRead = aDecoder.decodeObject(forKey: "permissionPaymentsRead") as? Bool
        permissionPaymentsWrite = aDecoder.decodeObject(forKey: "permissionPaymentsWrite") as? Bool
        permissionEmployeesRead = aDecoder.decodeObject(forKey: "permissionEmployeesRead") as? Bool
        permissionEmployeesWrite = aDecoder.decodeObject(forKey: "permissionEmployeesWrite") as? Bool
        permissionProcessCards = aDecoder.decodeObject(forKey: "permissionProcessCards") as? Bool
        permissionMidRead = aDecoder.decodeObject(forKey: "permissionMidRead") as? Bool
        privacyPolicy = aDecoder.decodeObject(forKey: "privacyPolicy") as? String
        eula = aDecoder.decodeObject(forKey: "eula") as? String
        supportPhone = aDecoder.decodeObject(forKey: "supportPhone") as? String
        supportPhoneHours = aDecoder.decodeObject(forKey: "supportPhoneHours") as? String
        supportEmail = aDecoder.decodeObject(forKey: "supportEmail") as? String
        supportUrl = aDecoder.decodeObject(forKey: "supportUrl") as? String
        if let productTypeString = (aDecoder.decodeObject(forKey: "productType") as? String) {
            productType = CLVModels.Apps.ProductType(rawValue: productTypeString)
        }
        if let approvalStatusString = (aDecoder.decodeObject(forKey: "approvalStatus") as? String) {
            approvalStatus = CLVModels.Base.ApprovalStatus(rawValue: approvalStatusString)
        }
        androidPermissions = aDecoder.decodeObject(forKey: "androidPermissions") as? [CLVModels.Apps.AndroidPermission]
        screenshots = aDecoder.decodeObject(forKey: "screenshots") as? [CLVModels.Apps.Screenshot]
        availableSubscriptions = aDecoder.decodeObject(forKey: "availableSubscriptions") as? [CLVModels.Apps.AppSubscription]
        subscriptions = aDecoder.decodeObject(forKey: "subscriptions") as? [CLVModels.Apps.AppSubscription]
        availableMetereds = aDecoder.decodeObject(forKey: "availableMetereds") as? [CLVModels.Apps.AppMetered]
        metereds = aDecoder.decodeObject(forKey: "metereds") as? [CLVModels.Apps.AppMetered]
        usbDevices = aDecoder.decodeObject(forKey: "usbDevices") as? [CLVModels.Apps.AppUsbDevice]
        currentSubscription = aDecoder.decodeObject(forKey: "currentSubscription") as? CLVModels.Apps.AppSubscription
        webhook = aDecoder.decodeObject(forKey: "webhook") as? CLVModels.Apps.WebHook
        androidVersions = aDecoder.decodeObject(forKey: "androidVersions") as? [CLVModels.Apps.AndroidVersion]
        installed = aDecoder.decodeObject(forKey: "installed") as? Bool
        installedTime = aDecoder.decodeObject(forKey: "installedTime") as? Date
        paidAppHasTrial = aDecoder.decodeObject(forKey: "paidAppHasTrial") as? Bool
        approvalStatusModifiedTime = aDecoder.decodeObject(forKey: "approvalStatusModifiedTime") as? Date
        smartReceiptText = aDecoder.decodeObject(forKey: "smartReceiptText") as? String
        smartReceiptUrl = aDecoder.decodeObject(forKey: "smartReceiptUrl") as? String
        billingStartTime = aDecoder.decodeObject(forKey: "billingStartTime") as? Date
        appSecret = aDecoder.decodeObject(forKey: "appSecret") as? String
        businessTypes = aDecoder.decodeObject(forKey: "businessTypes") as? [CLVModels.Apps.BusinessType]
        deviceTypes = aDecoder.decodeObject(forKey: "deviceTypes") as? [CLVModels.Apps.DeviceType]
        modules = aDecoder.decodeObject(forKey: "modules") as? [CLVModels.Merchant.Module]
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        id <- map["id"]
        name <- map["name"]
        published <- map["published"]
        developer <- map["developer"]
        merchant <- map["merchant"]
        description_ <- map["description"]
        tagline <- map["tagline"]
        videoUrl <- map["videoUrl"]
        activationUrl <- map["activationUrl"]
        siteUrl <- map["siteUrl"]
        defaultResponseType <- map["defaultResponseType"]
        appDomain <- map["appDomain"]
        androidVersion <- map["androidVersion"]
        packageName <- map["packageName"]
        approved <- map["approved"]
        systemApp <- map["systemApp"]
        hidden <- map["hidden"]
        filenameIcon <- map["filenameIcon"]
        filenameIconSmall <- map["filenameIconSmall"]
        filenameIconLarge <- map["filenameIconLarge"]
        installCount <- map["installCount"]
        sortOrder <- map["sortOrder"]
        permissionMerchantRead <- map["permissionMerchantRead"]
        permissionMerchantWrite <- map["permissionMerchantWrite"]
        permissionCustomersRead <- map["permissionCustomersRead"]
        permissionCustomersWrite <- map["permissionCustomersWrite"]
        permissionInventoryRead <- map["permissionInventoryRead"]
        permissionInventoryWrite <- map["permissionInventoryWrite"]
        permissionOrdersRead <- map["permissionOrdersRead"]
        permissionOrdersWrite <- map["permissionOrdersWrite"]
        permissionPaymentsRead <- map["permissionPaymentsRead"]
        permissionPaymentsWrite <- map["permissionPaymentsWrite"]
        permissionEmployeesRead <- map["permissionEmployeesRead"]
        permissionEmployeesWrite <- map["permissionEmployeesWrite"]
        permissionProcessCards <- map["permissionProcessCards"]
        permissionMidRead <- map["permissionMidRead"]
        privacyPolicy <- map["privacyPolicy"]
        eula <- map["eula"]
        supportPhone <- map["supportPhone"]
        supportPhoneHours <- map["supportPhoneHours"]
        supportEmail <- map["supportEmail"]
        supportUrl <- map["supportUrl"]
        productType <- map["productType"]
        approvalStatus <- map["approvalStatus"]
        androidPermissions <- map["androidPermissions.elements"]
        screenshots <- map["screenshots.elements"]
        availableSubscriptions <- map["availableSubscriptions.elements"]
        subscriptions <- map["subscriptions.elements"]
        availableMetereds <- map["availableMetereds.elements"]
        metereds <- map["metereds.elements"]
        usbDevices <- map["usbDevices.elements"]
        currentSubscription <- map["currentSubscription"]
        webhook <- map["webhook"]
        androidVersions <- map["androidVersions.elements"]
        installed <- map["installed"]
        installedTime <- (map["installedTime"], CLVDateTransform())
        paidAppHasTrial <- map["paidAppHasTrial"]
        approvalStatusModifiedTime <- (map["approvalStatusModifiedTime"], CLVDateTransform())
        smartReceiptText <- map["smartReceiptText"]
        smartReceiptUrl <- map["smartReceiptUrl"]
        billingStartTime <- (map["billingStartTime"], CLVDateTransform())
        appSecret <- map["appSecret"]
        businessTypes <- map["businessTypes.elements"]
        deviceTypes <- map["deviceTypes.elements"]
        modules <- map["modules.elements"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels4Apps14AppBillingInfo)public class AppBillingInfo: NSObject, NSCoding, Mappable {
      /// Current subscription level of the merchant for this app
      public var appSubscription: CLVModels.Apps.AppSubscription?
      /// Returns true if the merchant is in trial for this app.  Only valid for paid apps that offer trials.  Trials apply to app metereds and app subscriptions
      public var isInTrial: Bool?
      /// When the merchant's trial ends.  Only valid for paid apps that offer trials
      public var billingStartTime: Date?
      /// Returns active if a merchant has a credit card on file, and if it's currently authorizing properly.  Returns lapsed if their card is absent or most recently declined
      public var status: CLVModels.Apps.MerchantBillingStatus? = nil
      /// If the merchant's account is lapsed (i.e. merchant is behind on paying), the number of days since it lapsed
      public var daysLapsed: Int?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(appSubscription, forKey: "appSubscription")
        aCoder.encode(isInTrial, forKey: "isInTrial")
        aCoder.encode(billingStartTime, forKey: "billingStartTime")
        aCoder.encode(status?.rawValue, forKey: "status")
        aCoder.encode(daysLapsed, forKey: "daysLapsed")
      }
      
      required public init(coder aDecoder: NSCoder) {
        appSubscription = aDecoder.decodeObject(forKey: "appSubscription") as? CLVModels.Apps.AppSubscription
        isInTrial = aDecoder.decodeObject(forKey: "isInTrial") as? Bool
        billingStartTime = aDecoder.decodeObject(forKey: "billingStartTime") as? Date
        if let statusString = (aDecoder.decodeObject(forKey: "status") as? String) {
            status = CLVModels.Apps.MerchantBillingStatus(rawValue: statusString)
        }
        daysLapsed = aDecoder.decodeObject(forKey: "daysLapsed") as? Int
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        appSubscription <- map["appSubscription"]
        isInTrial <- map["isInTrial"]
        billingStartTime <- (map["billingStartTime"], CLVDateTransform())
        status <- map["status"]
        daysLapsed <- map["daysLapsed"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels4Apps9AppBundle)public class AppBundle: NSObject, NSCoding, Mappable {
      /// Unique identifier
      public var id: String?
      /// The name of the bundle
      public var name: String?
      public var includedApps: [CLVModels.Apps.App]?
      /// Bundle country options for this app bundle
      public var bundleCountries: [CLVModels.Apps.AppBundleCountry]?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(id, forKey: "id")
        aCoder.encode(name, forKey: "name")
        aCoder.encode(includedApps, forKey: "includedApps")
        aCoder.encode(bundleCountries, forKey: "bundleCountries")
      }
      
      required public init(coder aDecoder: NSCoder) {
        id = aDecoder.decodeObject(forKey: "id") as? String
        name = aDecoder.decodeObject(forKey: "name") as? String
        includedApps = aDecoder.decodeObject(forKey: "includedApps") as? [CLVModels.Apps.App]
        bundleCountries = aDecoder.decodeObject(forKey: "bundleCountries") as? [CLVModels.Apps.AppBundleCountry]
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        id <- map["id"]
        name <- map["name"]
        includedApps <- map["includedApps.elements"]
        bundleCountries <- map["bundleCountries.elements"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels4Apps16AppBundleCountry)public class AppBundleCountry: NSObject, NSCoding, Mappable {
      /// Unique identifier
      public var id: String?
      public var price: Int?
      public var pricePerDevice: Int?
      /// The country of the app bundle country
      public var country: String?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(id, forKey: "id")
        aCoder.encode(price, forKey: "price")
        aCoder.encode(pricePerDevice, forKey: "pricePerDevice")
        aCoder.encode(country, forKey: "country")
      }
      
      required public init(coder aDecoder: NSCoder) {
        id = aDecoder.decodeObject(forKey: "id") as? String
        price = aDecoder.decodeObject(forKey: "price") as? Int
        pricePerDevice = aDecoder.decodeObject(forKey: "pricePerDevice") as? Int
        country = aDecoder.decodeObject(forKey: "country") as? String
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        id <- map["id"]
        price <- map["price"]
        pricePerDevice <- map["pricePerDevice"]
        country <- map["country"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels4Apps11AppCarousel)public class AppCarousel: NSObject, NSCoding, Mappable {
      /// Unique identifier
      public var id: String?
      public var name: String?
      public var countryCode: String?
      public var reseller: CLVModels.Base.Reference?
      public var maxSize: Int?
      public var carouselApps: [CLVModels.Apps.App]?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(id, forKey: "id")
        aCoder.encode(name, forKey: "name")
        aCoder.encode(countryCode, forKey: "countryCode")
        aCoder.encode(reseller, forKey: "reseller")
        aCoder.encode(maxSize, forKey: "maxSize")
        aCoder.encode(carouselApps, forKey: "carouselApps")
      }
      
      required public init(coder aDecoder: NSCoder) {
        id = aDecoder.decodeObject(forKey: "id") as? String
        name = aDecoder.decodeObject(forKey: "name") as? String
        countryCode = aDecoder.decodeObject(forKey: "countryCode") as? String
        reseller = aDecoder.decodeObject(forKey: "reseller") as? CLVModels.Base.Reference
        maxSize = aDecoder.decodeObject(forKey: "maxSize") as? Int
        carouselApps = aDecoder.decodeObject(forKey: "carouselApps") as? [CLVModels.Apps.App]
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        id <- map["id"]
        name <- map["name"]
        countryCode <- map["countryCode"]
        reseller <- map["reseller"]
        maxSize <- map["maxSize"]
        carouselApps <- map["carouselApps.elements"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels4Apps10AppMetered)public class AppMetered: NSObject, NSCoding, Mappable {
      /// Unique identifier
      public var id: String?
      /// Metered country options for this app metered
      public var meteredCountries: [CLVModels.Apps.AppMeteredCountry]?
      /// Reference to the app this metered belongs to
      public var app: CLVModels.Apps.App?
      /// A label used to identify this metered action
      public var label: String?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(id, forKey: "id")
        aCoder.encode(meteredCountries, forKey: "meteredCountries")
        aCoder.encode(app, forKey: "app")
        aCoder.encode(label, forKey: "label")
      }
      
      required public init(coder aDecoder: NSCoder) {
        id = aDecoder.decodeObject(forKey: "id") as? String
        meteredCountries = aDecoder.decodeObject(forKey: "meteredCountries") as? [CLVModels.Apps.AppMeteredCountry]
        app = aDecoder.decodeObject(forKey: "app") as? CLVModels.Apps.App
        label = aDecoder.decodeObject(forKey: "label") as? String
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        id <- map["id"]
        meteredCountries <- map["meteredCountries.elements"]
        app <- map["app"]
        label <- map["label"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels4Apps17AppMeteredCountry)public class AppMeteredCountry: NSObject, NSCoding, Mappable {
      /// Unique identifier
      public var id: String?
      /// App metered action
      public var action: String?
      /// The cost of the metered country
      public var amount: Int?
      /// The country of the metered country
      public var country: String?
      /// App metered country active status
      public var active: Bool?
      /// Reference to metered this metered country belongs to
      public var appMetered: CLVModels.Apps.AppMetered?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(id, forKey: "id")
        aCoder.encode(action, forKey: "action")
        aCoder.encode(amount, forKey: "amount")
        aCoder.encode(country, forKey: "country")
        aCoder.encode(active, forKey: "active")
        aCoder.encode(appMetered, forKey: "appMetered")
      }
      
      required public init(coder aDecoder: NSCoder) {
        id = aDecoder.decodeObject(forKey: "id") as? String
        action = aDecoder.decodeObject(forKey: "action") as? String
        amount = aDecoder.decodeObject(forKey: "amount") as? Int
        country = aDecoder.decodeObject(forKey: "country") as? String
        active = aDecoder.decodeObject(forKey: "active") as? Bool
        appMetered = aDecoder.decodeObject(forKey: "appMetered") as? CLVModels.Apps.AppMetered
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        id <- map["id"]
        action <- map["action"]
        amount <- map["amount"]
        country <- map["country"]
        active <- map["active"]
        appMetered <- map["appMetered"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels4Apps15AppNotification)public class AppNotification: NSObject, NSCoding, Mappable {
      /// The app the notification will be sent to. This will be autopopulated by the server.
      public var app: CLVModels.Apps.App?
      /// 
      public var event: String?
      /// The time to live of the notification in seconds. By default this is 5 days.
      public var timeToLive: Int?
      /// Payload of the notification. This is at most 4000 characters.
      public var data: String?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(app, forKey: "app")
        aCoder.encode(event, forKey: "event")
        aCoder.encode(timeToLive, forKey: "timeToLive")
        aCoder.encode(data, forKey: "data")
      }
      
      required public init(coder aDecoder: NSCoder) {
        app = aDecoder.decodeObject(forKey: "app") as? CLVModels.Apps.App
        event = aDecoder.decodeObject(forKey: "event") as? String
        timeToLive = aDecoder.decodeObject(forKey: "timeToLive") as? Int
        data = aDecoder.decodeObject(forKey: "data") as? String
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        app <- map["app"]
        event <- map["event"]
        timeToLive <- map["timeToLive"]
        data <- map["data"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels4Apps15AppSubscription)public class AppSubscription: NSObject, NSCoding, Mappable {
      /// Unique identifier
      public var id: String?
      /// Subscription country options for this app subscription
      public var subscriptionCountries: [CLVModels.Apps.AppSubscriptionCountry]?
      /// Reference to app this subscription belongs to
      public var app: CLVModels.Apps.App?
      /// App subscription label
      public var label: String?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(id, forKey: "id")
        aCoder.encode(app, forKey: "app")
        aCoder.encode(label, forKey: "label")
      }
      
      required public init(coder aDecoder: NSCoder) {
        id = aDecoder.decodeObject(forKey: "id") as? String
        app = aDecoder.decodeObject(forKey: "app") as? CLVModels.Apps.App
        label = aDecoder.decodeObject(forKey: "label") as? String
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        id <- map["id"]
        app <- map["app"]
        label <- map["label"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels4Apps22AppSubscriptionCountry)public class AppSubscriptionCountry: NSObject, NSCoding, Mappable {
      /// Unique identifier
      public var id: String?
      /// App subscription country name
      public var name: String?
      /// The cost of the subscription country
      public var amount: Int?
      /// The country of the subscription country
      public var country: String?
      /// App subscription country name
      public var description_: String?
      /// App subscription country active status
      public var active: Bool?
      /// Reference to subscription this subscription country belongs to
      public var appSubscription: CLVModels.Apps.AppSubscription?
      /// The number of merchants that have this app subscription country installed
      public var installCount: Int?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(id, forKey: "id")
        aCoder.encode(name, forKey: "name")
        aCoder.encode(amount, forKey: "amount")
        aCoder.encode(country, forKey: "country")
        aCoder.encode(description_, forKey: "description_")
        aCoder.encode(active, forKey: "active")
        aCoder.encode(appSubscription, forKey: "appSubscription")
        aCoder.encode(installCount, forKey: "installCount")
      }
      
      required public init(coder aDecoder: NSCoder) {
        id = aDecoder.decodeObject(forKey: "id") as? String
        name = aDecoder.decodeObject(forKey: "name") as? String
        amount = aDecoder.decodeObject(forKey: "amount") as? Int
        country = aDecoder.decodeObject(forKey: "country") as? String
        description_ = aDecoder.decodeObject(forKey: "description_") as? String
        active = aDecoder.decodeObject(forKey: "active") as? Bool
        appSubscription = aDecoder.decodeObject(forKey: "appSubscription") as? CLVModels.Apps.AppSubscription
        installCount = aDecoder.decodeObject(forKey: "installCount") as? Int
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        id <- map["id"]
        name <- map["name"]
        amount <- map["amount"]
        country <- map["country"]
        description_ <- map["description"]
        active <- map["active"]
        appSubscription <- map["appSubscription"]
        installCount <- map["installCount"]
      }
    }
    
    /// Used to track the origin of a distributed call.
    @objc(_TtCCC15CloverConnector9CLVModels4Apps11AppTracking)public class AppTracking: NSObject, NSCoding, Mappable {
        
        /// The uuid from the developer application.  This is typically populated and used only on the back end.
        public var developerAppId: String?
        
        /// The name of the developer application.
        public var applicationName: String?
        
        /// A string representing an application
        public var applicationID: String?
        
        /// A string representing a semanticversion.  See http://semver.org/
        public var applicationVersion: String?
        
        /// A string representing a SDK
        public var sourceSDK: String?
        
        /// A string representing a semanticversion.  See http://semver.org/
        public var sourceSDKVersion: String?
        
        public func encode(with aCoder: NSCoder) {
            aCoder.encode(developerAppId, forKey: "developerAppId")
            aCoder.encode(applicationName, forKey: "applicationName")
            aCoder.encode(applicationID, forKey: "applicationID")
            aCoder.encode(applicationVersion, forKey: "applicationVersion")
            aCoder.encode(sourceSDK, forKey: "sourceSDK")
            aCoder.encode(sourceSDKVersion, forKey: "sourceSDKVersion")
        }
        
        required public init(coder aDecoder: NSCoder) {
            developerAppId = aDecoder.decodeObject(forKey: "developerAppId") as? String
            applicationName = aDecoder.decodeObject(forKey: "applicationName") as? String
            applicationID = aDecoder.decodeObject(forKey: "applicationID") as? String
            applicationVersion = aDecoder.decodeObject(forKey: "applicationVersion") as? String
            sourceSDK = aDecoder.decodeObject(forKey: "sourceSDK") as? String
            sourceSDKVersion = aDecoder.decodeObject(forKey: "sourceSDKVersion") as? String
        }
        
        override public init() {}
        
        // Mappable
        required public init?(map:Map) {}
        
        public func mapping(map:Map) {
            developerAppId <- map["developerAppId"]
            applicationName <- map["applicationName"]
            applicationID <- map["applicationID"]
            applicationVersion <- map["applicationVersion"]
            sourceSDK <- map["sourceSDK"]
            sourceSDKVersion <- map["sourceSDKVersion"]
        }
    }
    
    @objc(_TtCCC15CloverConnector9CLVModels4Apps12AppUsbDevice)public class AppUsbDevice: NSObject, NSCoding, Mappable {
      public var packageName: String?
      public var vendorId: Int?
      public var productId: Int?
      public var app: CLVModels.Apps.App?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(packageName, forKey: "packageName")
        aCoder.encode(vendorId, forKey: "vendorId")
        aCoder.encode(productId, forKey: "productId")
        aCoder.encode(app, forKey: "app")
      }
      
      required public init(coder aDecoder: NSCoder) {
        packageName = aDecoder.decodeObject(forKey: "packageName") as? String
        vendorId = aDecoder.decodeObject(forKey: "vendorId") as? Int
        productId = aDecoder.decodeObject(forKey: "productId") as? Int
        app = aDecoder.decodeObject(forKey: "app") as? CLVModels.Apps.App
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        packageName <- map["packageName"]
        vendorId <- map["vendorId"]
        productId <- map["productId"]
        app <- map["app"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels4Apps12BusinessType)public class BusinessType: NSObject, NSCoding, Mappable {
      public var businessTypeGroupCode: CLVModels.Apps.BusinessTypeGroupCode? = nil
      /// localized business type group
      public var businessTypeGroupName: String?
      public var code: CLVModels.Base.BusinessTypeCode? = nil
      /// Localized business type
      public var name: String?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(businessTypeGroupCode?.rawValue, forKey: "businessTypeGroupCode")
        aCoder.encode(businessTypeGroupName, forKey: "businessTypeGroupName")
        aCoder.encode(code?.rawValue, forKey: "code")
        aCoder.encode(name, forKey: "name")
      }
      
      required public init(coder aDecoder: NSCoder) {
        if let businessTypeGroupCodeString = (aDecoder.decodeObject(forKey: "businessTypeGroupCode") as? String) {
            businessTypeGroupCode = CLVModels.Apps.BusinessTypeGroupCode(rawValue: businessTypeGroupCodeString)
        }
        businessTypeGroupName = aDecoder.decodeObject(forKey: "businessTypeGroupName") as? String
        if let codeString = (aDecoder.decodeObject(forKey: "code") as? String) {
            code = CLVModels.Base.BusinessTypeCode(rawValue: codeString)
        }
        name = aDecoder.decodeObject(forKey: "name") as? String
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        businessTypeGroupCode <- map["businessTypeGroupCode"]
        businessTypeGroupName <- map["businessTypeGroupName"]
        code <- map["code"]
        name <- map["name"]
      }
    }
    
    
    
    public enum BusinessTypeGroupCode: String {
      case FOOD
      case RETAIL
      case SERVICES
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels4Apps10DeviceType)public class DeviceType: NSObject, NSCoding, Mappable {
      public var name: String?
      public var displayName: String?
      public var models: String?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(name, forKey: "name")
        aCoder.encode(displayName, forKey: "displayName")
        aCoder.encode(models, forKey: "models")
      }
      
      required public init(coder aDecoder: NSCoder) {
        name = aDecoder.decodeObject(forKey: "name") as? String
        displayName = aDecoder.decodeObject(forKey: "displayName") as? String
        models = aDecoder.decodeObject(forKey: "models") as? String
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        name <- map["name"]
        displayName <- map["displayName"]
        models <- map["models"]
      }
    }
    
    
    
    public enum MerchantBillingStatus: String {
      case ACTIVE
      case LAPSED
    }
    
    
    
    public enum OAuthResponseType: String {
      case TOKEN
      case CODE
    }
    
    
    
    public enum ProductType: String {
      case ANDROID
      case WEB
      case BOTH
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels4Apps11ReleaseNote)public class ReleaseNote: NSObject, NSCoding, Mappable {
      public var id: String?
      /// The contents of the release note
      public var note: String?
      /// Timestamp indicating when the group was created.
      public var createdTime: Date?
      /// Timestamp indicating when the note was last updated.
      public var modifiedTime: Date?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(id, forKey: "id")
        aCoder.encode(note, forKey: "note")
        aCoder.encode(createdTime, forKey: "createdTime")
        aCoder.encode(modifiedTime, forKey: "modifiedTime")
      }
      
      required public init(coder aDecoder: NSCoder) {
        id = aDecoder.decodeObject(forKey: "id") as? String
        note = aDecoder.decodeObject(forKey: "note") as? String
        createdTime = aDecoder.decodeObject(forKey: "createdTime") as? Date
        modifiedTime = aDecoder.decodeObject(forKey: "modifiedTime") as? Date
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        id <- map["id"]
        note <- map["note"]
        createdTime <- (map["createdTime"], CLVDateTransform())
        modifiedTime <- (map["modifiedTime"], CLVDateTransform())
      }
    }
    
    
    
    public enum ScanStatus: String {
      case NOT_SCANNED
      case IN_PROGRESS
      case PASSED
      case FAILED
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels4Apps10Screenshot)public class Screenshot: NSObject, NSCoding, Mappable {
      /// URL for the app screenshot
      public var name: String?
      /// URL for the small version (80 x 80) of the app screenshot
      public var small: String?
      /// URL for the medium version (200 x 200) of the app screenshot
      public var medium: String?
      /// URL for the large version (800 x 800) of the app screenshot
      public var large: String?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(name, forKey: "name")
        aCoder.encode(small, forKey: "small")
        aCoder.encode(medium, forKey: "medium")
        aCoder.encode(large, forKey: "large")
      }
      
      required public init(coder aDecoder: NSCoder) {
        name = aDecoder.decodeObject(forKey: "name") as? String
        small = aDecoder.decodeObject(forKey: "small") as? String
        medium = aDecoder.decodeObject(forKey: "medium") as? String
        large = aDecoder.decodeObject(forKey: "large") as? String
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        name <- map["name"]
        small <- map["small"]
        medium <- map["medium"]
        large <- map["large"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels4Apps7WebHook)public class WebHook: NSObject, NSCoding, Mappable {
      public var url: String?
      /// A secret string included as a header in the HTTP request from Clover to the developer's web hook callback URL.
      public var secret: String?
      public var valid: Bool?
      /// The verification code that was sent to the developer's web hook callback URL.
      public var verification: String?
      public var orders: Bool?
      public var app: Bool?
      public var payments: Bool?
      public var inventory: Bool?
      public var customers: Bool?
      public var merchants: Bool?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(url, forKey: "url")
        aCoder.encode(secret, forKey: "secret")
        aCoder.encode(valid, forKey: "valid")
        aCoder.encode(verification, forKey: "verification")
        aCoder.encode(orders, forKey: "orders")
        aCoder.encode(app, forKey: "app")
        aCoder.encode(payments, forKey: "payments")
        aCoder.encode(inventory, forKey: "inventory")
        aCoder.encode(customers, forKey: "customers")
        aCoder.encode(merchants, forKey: "merchants")
      }
      
      required public init(coder aDecoder: NSCoder) {
        url = aDecoder.decodeObject(forKey: "url") as? String
        secret = aDecoder.decodeObject(forKey: "secret") as? String
        valid = aDecoder.decodeObject(forKey: "valid") as? Bool
        verification = aDecoder.decodeObject(forKey: "verification") as? String
        orders = aDecoder.decodeObject(forKey: "orders") as? Bool
        app = aDecoder.decodeObject(forKey: "app") as? Bool
        payments = aDecoder.decodeObject(forKey: "payments") as? Bool
        inventory = aDecoder.decodeObject(forKey: "inventory") as? Bool
        customers = aDecoder.decodeObject(forKey: "customers") as? Bool
        merchants = aDecoder.decodeObject(forKey: "merchants") as? Bool
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        url <- map["url"]
        secret <- map["secret"]
        valid <- map["valid"]
        verification <- map["verification"]
        orders <- map["orders"]
        app <- map["app"]
        payments <- map["payments"]
        inventory <- map["inventory"]
        customers <- map["customers"]
        merchants <- map["merchants"]
      }
    }
    
  }
}
