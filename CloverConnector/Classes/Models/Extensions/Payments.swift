
/**
 * Autogenerated by Avro
 *
 * DO NOT EDIT DIRECTLY
 */

import ObjectMapper

extension CLVModels {
  public class Payments {
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments13Authorization)public class Authorization: NSObject, NSCoding, Mappable {
      /// Unique identifier
      public var id: String?
      /// Payment that the auth was opened with
      public var payment: CLVModels.Payments.Payment?
      /// Name of tab
      public var tabName: String?
      /// Amount authorized
      public var amount: Int?
      /// Type of credit card used for authorization
      public var cardType: CLVModels.Payments.CardType? = nil
      /// Last 4 digits of credit card used for authorization
      public var last4: String?
      /// Authorization code
      public var authcode: String?
      public var type_: CLVModels.Payments.Type_? = nil
      public var note: String?
      /// Payment that the auth was closed with
      public var closingPayment: CLVModels.Payments.Payment?
      /// Time authorization was recorded on server
      public var createdTime: Date?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(id, forKey: "id")
        aCoder.encode(payment, forKey: "payment")
        aCoder.encode(tabName, forKey: "tabName")
        aCoder.encode(amount, forKey: "amount")
        aCoder.encode(cardType?.rawValue, forKey: "cardType")
        aCoder.encode(last4, forKey: "last4")
        aCoder.encode(authcode, forKey: "authcode")
        aCoder.encode(type_?.rawValue, forKey: "type_")
        aCoder.encode(note, forKey: "note")
        aCoder.encode(closingPayment, forKey: "closingPayment")
        aCoder.encode(createdTime, forKey: "createdTime")
      }
      
      required public init(coder aDecoder: NSCoder) {
        id = aDecoder.decodeObject(forKey: "id") as? String
        payment = aDecoder.decodeObject(forKey: "payment") as? CLVModels.Payments.Payment
        tabName = aDecoder.decodeObject(forKey: "tabName") as? String
        amount = aDecoder.decodeObject(forKey: "amount") as? Int
        if let cardTypeString = aDecoder.decodeObject(forKey: "cardType") as? String {
            cardType = CLVModels.Payments.CardType(rawValue: cardTypeString)
        }
        last4 = aDecoder.decodeObject(forKey: "last4") as? String
        authcode = aDecoder.decodeObject(forKey: "authcode") as? String
        if let typeString = aDecoder.decodeObject(forKey: "type_") as? String {
            type_ = CLVModels.Payments.Type_(rawValue: typeString)
        }
        note = aDecoder.decodeObject(forKey: "note") as? String
        closingPayment = aDecoder.decodeObject(forKey: "closingPayment") as? CLVModels.Payments.Payment
        createdTime = aDecoder.decodeObject(forKey: "createdTime") as? Date
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        id <- map["id"]
        payment <- map["payment"]
        tabName <- map["tabName"]
        amount <- map["amount"]
        cardType <- map["cardType"]
        last4 <- map["last4"]
        authcode <- map["authcode"]
        type_ <- map["type"]
        note <- map["note"]
        closingPayment <- map["closingPayment"]
        createdTime <- (map["createdTime"], CLVDateTransform())
      }
    }
    
    
    
    public enum AVSResult: String {
      case SUCCESS
      case ZIP_CODE_MATCH
      case ZIP_CODE_MATCH_ADDRESS_NOT_CHECKED
      case ADDRESS_MATCH
      case ADDRESS_MATCH_ZIP_NOT_CHECKED
      case NEITHER_MATCH
      case SERVICE_FAILURE
      case SERVICE_UNAVAILABLE
      case NOT_CHECKED
      case ZIP_CODE_NOT_MATCHED_ADDRESS_NOT_CHECKED
      case ADDRESS_NOT_MATCHED_ZIP_CODE_NOT_CHECKED
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments5Batch)public class Batch: NSObject, NSCoding, Mappable {
      public var id: String?
      public var merchantId: Int?
      public var firstGatewayTxId: Int?
      public var lastGatewayTxId: Int?
      /// The id of employee who executed batch
      public var accountId: Int?
      /// The number of transactions being batched
      public var txCount: Int?
      /// Total amount closed
      public var totalBatchAmount: Int?
      /// List of devices in batch
      public var devices: String?
      public var state: CLVModels.Payments.BatchState? = nil
      public var batchType: CLVModels.Payments.BatchType? = nil
      /// Created time of batch
      public var createdTime: Date?
      /// Modified time of batch
      public var modifiedTime: Date?
      /// Details split based on card / employees
      public var batchDetails: CLVModels.Payments.BatchDetail?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(id, forKey: "id")
        aCoder.encode(merchantId, forKey: "merchantId")
        aCoder.encode(firstGatewayTxId, forKey: "firstGatewayTxId")
        aCoder.encode(lastGatewayTxId, forKey: "lastGatewayTxId")
        aCoder.encode(accountId, forKey: "accountId")
        aCoder.encode(txCount, forKey: "txCount")
        aCoder.encode(totalBatchAmount, forKey: "totalBatchAmount")
        aCoder.encode(devices, forKey: "devices")
        aCoder.encode(state?.rawValue, forKey: "state")
        aCoder.encode(batchType?.rawValue, forKey: "batchType")
        aCoder.encode(createdTime, forKey: "createdTime")
        aCoder.encode(modifiedTime, forKey: "modifiedTime")
        aCoder.encode(batchDetails, forKey: "batchDetails")
      }
      
      required public init(coder aDecoder: NSCoder) {
        id = aDecoder.decodeObject(forKey: "id") as? String
        merchantId = aDecoder.decodeObject(forKey: "merchantId") as? Int
        firstGatewayTxId = aDecoder.decodeObject(forKey: "firstGatewayTxId") as? Int
        lastGatewayTxId = aDecoder.decodeObject(forKey: "lastGatewayTxId") as? Int
        accountId = aDecoder.decodeObject(forKey: "accountId") as? Int
        txCount = aDecoder.decodeObject(forKey: "txCount") as? Int
        totalBatchAmount = aDecoder.decodeObject(forKey: "totalBatchAmount") as? Int
        devices = aDecoder.decodeObject(forKey: "devices") as? String
        if let stateString = aDecoder.decodeObject(forKey: "state") as? String {
            state = CLVModels.Payments.BatchState(rawValue: stateString)
        }
        if let batchTypeString = aDecoder.decodeObject(forKey: "batchType") as? String {
            batchType = CLVModels.Payments.BatchType(rawValue: batchTypeString)
        }
        createdTime = aDecoder.decodeObject(forKey: "createdTime") as? Date
        modifiedTime = aDecoder.decodeObject(forKey: "modifiedTime") as? Date
        batchDetails = aDecoder.decodeObject(forKey: "batchDetails") as? CLVModels.Payments.BatchDetail
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        id <- map["id"]
        merchantId <- map["merchantId"]
        firstGatewayTxId <- map["firstGatewayTxId"]
        lastGatewayTxId <- map["lastGatewayTxId"]
        accountId <- map["accountId"]
        txCount <- map["txCount"]
        totalBatchAmount <- map["totalBatchAmount"]
        devices <- map["devices"]
        state <- map["state"]
        batchType <- map["batchType"]
        createdTime <- (map["createdTime"], CLVDateTransform())
        modifiedTime <- (map["modifiedTime"], CLVDateTransform())
        batchDetails <- map["batchDetails"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments14BatchCardTotal)public class BatchCardTotal: NSObject, NSCoding, Mappable {
      public var cardType: CLVModels.Payments.CardType? = nil
      /// Total count of types
      public var count: Int?
      /// Total amount for type
      public var total: Int?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(cardType?.rawValue, forKey: "cardType")
        aCoder.encode(count, forKey: "count")
        aCoder.encode(total, forKey: "total")
      }
      
      required public init(coder aDecoder: NSCoder) {
        if let cardTypeString = aDecoder.decodeObject(forKey: "cardType") as? String {
            cardType = CLVModels.Payments.CardType(rawValue: cardTypeString)
        }
        count = aDecoder.decodeObject(forKey: "count") as? Int
        total = aDecoder.decodeObject(forKey: "total") as? Int
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        cardType <- map["cardType"]
        count <- map["count"]
        total <- map["total"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments11BatchDetail)public class BatchDetail: NSObject, NSCoding, Mappable {
      public var batchTotals: CLVModels.Payments.BatchTotalStats?
      public var serverTotals: [CLVModels.Payments.ServerTotalStats]?
      public var cardTotals: [CLVModels.Payments.BatchCardTotal]?
      /// Number of public tips.
      public var openTips: Int?
      /// Number of public tabs.
      public var openTabs: Int?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(batchTotals, forKey: "batchTotals")
        aCoder.encode(serverTotals, forKey: "serverTotals")
        aCoder.encode(cardTotals, forKey: "cardTotals")
        aCoder.encode(openTips, forKey: "openTips")
        aCoder.encode(openTabs, forKey: "openTabs")
      }
      
      required public init(coder aDecoder: NSCoder) {
        batchTotals = aDecoder.decodeObject(forKey: "batchTotals") as? CLVModels.Payments.BatchTotalStats
        serverTotals = aDecoder.decodeObject(forKey: "serverTotals") as? [CLVModels.Payments.ServerTotalStats]
        cardTotals = aDecoder.decodeObject(forKey: "cardTotals") as? [CLVModels.Payments.BatchCardTotal]
        openTips = aDecoder.decodeObject(forKey: "openTips") as? Int
        openTabs = aDecoder.decodeObject(forKey: "openTabs") as? Int
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        batchTotals <- map["batchTotals"]
        serverTotals <- map["serverTotals.elements"]
        cardTotals <- map["cardTotals.elements"]
        openTips <- map["openTips"]
        openTabs <- map["openTabs"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments12BatchRequest)public class BatchRequest: NSObject, NSCoding, Mappable {
      public var devices: [String]?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(devices, forKey: "devices")
      }
      
      required public init(coder aDecoder: NSCoder) {
        devices = aDecoder.decodeObject(forKey: "devices") as? [String]
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        devices <- map["devices"]
      }
    }
    
    
    
    public enum BatchState: String {
      case OPEN
      case QUEUED_FOR_PROCESSING
      case PROCESSING
      case CLOSED
      case FAILED
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments15BatchTotalStats)public class BatchTotalStats: NSObject, NSCoding, Mappable {
      public var sales: CLVModels.Payments.BatchTotalType?
      public var refunds: CLVModels.Payments.BatchTotalType?
      public var net: CLVModels.Payments.BatchTotalType?
      public var giftCardLoads: CLVModels.Payments.BatchTotalType?
      public var giftCardCashOuts: CLVModels.Payments.BatchTotalType?
      public var tax: CLVModels.Payments.BatchTotalType?
      public var tips: CLVModels.Payments.BatchTotalType?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(sales, forKey: "sales")
        aCoder.encode(refunds, forKey: "refunds")
        aCoder.encode(net, forKey: "net")
        aCoder.encode(giftCardLoads, forKey: "giftCardLoads")
        aCoder.encode(giftCardCashOuts, forKey: "giftCardCashOuts")
        aCoder.encode(tax, forKey: "tax")
        aCoder.encode(tips, forKey: "tips")
      }
      
      required public init(coder aDecoder: NSCoder) {
        sales = aDecoder.decodeObject(forKey: "sales") as? CLVModels.Payments.BatchTotalType
        refunds = aDecoder.decodeObject(forKey: "refunds") as? CLVModels.Payments.BatchTotalType
        net = aDecoder.decodeObject(forKey: "net") as? CLVModels.Payments.BatchTotalType
        giftCardLoads = aDecoder.decodeObject(forKey: "giftCardLoads") as? CLVModels.Payments.BatchTotalType
        giftCardCashOuts = aDecoder.decodeObject(forKey: "giftCardCashOuts") as? CLVModels.Payments.BatchTotalType
        tax = aDecoder.decodeObject(forKey: "tax") as? CLVModels.Payments.BatchTotalType
        tips = aDecoder.decodeObject(forKey: "tips") as? CLVModels.Payments.BatchTotalType
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        sales <- map["sales"]
        refunds <- map["refunds"]
        net <- map["net"]
        giftCardLoads <- map["giftCardLoads"]
        giftCardCashOuts <- map["giftCardCashOuts"]
        tax <- map["tax"]
        tips <- map["tips"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments14BatchTotalType)public class BatchTotalType: NSObject, NSCoding, Mappable {
      /// Total count of types
      public var count: Int?
      /// Total amount for type
      public var total: Int?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(count, forKey: "count")
        aCoder.encode(total, forKey: "total")
      }
      
      required public init(coder aDecoder: NSCoder) {
        count = aDecoder.decodeObject(forKey: "count") as? Int
        total = aDecoder.decodeObject(forKey: "total") as? Int
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        count <- map["count"]
        total <- map["total"]
      }
    }
    
    
    
    public enum BatchType: String {
      case MANUAL_CLOSE
      case AUTO_CLOSE
    }
    
    
    
    public enum CardEntryType: String {
      case SWIPED
      case KEYED
      case VOICE
      case VAULTED
      case OFFLINE_SWIPED
      case OFFLINE_KEYED
      case EMV_CONTACT
      case EMV_CONTACTLESS
      case MSD_CONTACTLESS
      case PINPAD_MANUAL_ENTRY
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments15CardTransaction)public class CardTransaction: NSObject, NSCoding, Mappable {
      /// The payment with which the card transaction is associated
      public var paymentRef: CLVModels.Payments.Payment?
      /// The credit with which the card transaction is associated
      public var creditRef: CLVModels.Payments.Credit?
      public var cardType: CLVModels.Payments.CardType? = nil
      public var entryType: CLVModels.Payments.CardEntryType? = nil
      /// The first four digits of the card number
      public var first6: String?
      /// The last four digits of the card number
      public var last4: String?
      public var type_: CLVModels.Payments.CardTransactionType? = nil
      /// Authorization code (if successful)
      public var authCode: String?
      public var referenceId: String?
      public var transactionNo: String?
      public var state: CLVModels.Payments.CardTransactionState? = nil
      /// Extra info to be stored as part of gateway/card transaction
      public var extra: [String:String]?
      public var begBalance: Int?
      public var endBalance: Int?
      public var avsResult: CLVModels.Payments.AVSResult? = nil
      public var cardholderName: String?
      public var token: String?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(paymentRef, forKey: "paymentRef")
        aCoder.encode(creditRef, forKey: "creditRef")
        aCoder.encode(cardType?.rawValue, forKey: "cardType")
        aCoder.encode(entryType?.rawValue, forKey: "entryType")
        aCoder.encode(first6, forKey: "first6")
        aCoder.encode(last4, forKey: "last4")
        aCoder.encode(type_?.rawValue, forKey: "type_")
        aCoder.encode(authCode, forKey: "authCode")
        aCoder.encode(referenceId, forKey: "referenceId")
        aCoder.encode(transactionNo, forKey: "transactionNo")
        aCoder.encode(state?.rawValue, forKey: "state")
        aCoder.encode(extra, forKey: "extra")
        aCoder.encode(begBalance, forKey: "begBalance")
        aCoder.encode(endBalance, forKey: "endBalance")
        aCoder.encode(avsResult?.rawValue, forKey: "avsResult")
        aCoder.encode(cardholderName, forKey: "cardholderName")
        aCoder.encode(token, forKey: "token")
      }
      
      required public init(coder aDecoder: NSCoder) {
        paymentRef = aDecoder.decodeObject(forKey: "paymentRef") as? CLVModels.Payments.Payment
        creditRef = aDecoder.decodeObject(forKey: "creditRef") as? CLVModels.Payments.Credit
        if let cardTypeString = aDecoder.decodeObject(forKey: "cardType") as? String {
            cardType = CLVModels.Payments.CardType(rawValue: cardTypeString)
        }
        if let entryTypeString = aDecoder.decodeObject(forKey: "entryType") as? String {
            entryType = CLVModels.Payments.CardEntryType(rawValue: entryTypeString)
        }
        first6 = aDecoder.decodeObject(forKey: "first6") as? String
        last4 = aDecoder.decodeObject(forKey: "last4") as? String
        if let typeString = aDecoder.decodeObject(forKey: "type_") as? String {
            type_ = CLVModels.Payments.CardTransactionType(rawValue: typeString)
        }
        authCode = aDecoder.decodeObject(forKey: "authCode") as? String
        referenceId = aDecoder.decodeObject(forKey: "referenceId") as? String
        transactionNo = aDecoder.decodeObject(forKey: "transactionNo") as? String
        if let stateString = aDecoder.decodeObject(forKey: "state") as? String {
            state = CLVModels.Payments.CardTransactionState(rawValue: stateString)
        }
        extra = aDecoder.decodeObject(forKey: "extra") as? [String:String]
        begBalance = aDecoder.decodeObject(forKey: "begBalance") as? Int
        endBalance = aDecoder.decodeObject(forKey: "endBalance") as? Int
        if let avsResultString = aDecoder.decodeObject(forKey: "avsResult") as? String {
            avsResult = CLVModels.Payments.AVSResult(rawValue: avsResultString)
        }
        cardholderName = aDecoder.decodeObject(forKey: "cardholderName") as? String
        token = aDecoder.decodeObject(forKey: "token") as? String
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        paymentRef <- map["paymentRef"]
        creditRef <- map["creditRef"]
        cardType <- map["cardType"]
        entryType <- map["entryType"]
        first6 <- map["first6"]
        last4 <- map["last4"]
        type_ <- map["type"]
        authCode <- map["authCode"]
        referenceId <- map["referenceId"]
        transactionNo <- map["transactionNo"]
        state <- map["state"]
        extra <- map["extra"]
        begBalance <- map["begBalance"]
        endBalance <- map["endBalance"]
        avsResult <- map["avsResult"]
        cardholderName <- map["cardholderName"]
        token <- map["token"]
      }
    }
    
    
    
    public enum CardTransactionState: String {
      case PENDING
      case CLOSED
    }
    
    
    
    public enum CardTransactionType: String {
      case AUTH
      case PREAUTH
      case PREAUTHCAPTURE
      case ADJUST
      case VOID
      case VOIDRETURN
      case RETURN
      case REFUND
      case NAKEDREFUND
      case GETBALANCE
      case BATCHCLOSE
      case ACTIVATE
      case BALANCE_LOCK
      case LOAD
      case CASHOUT
      case CASHOUT_ACTIVE_STATUS
      case REDEMPTION
      case REDEMPTION_UNLOCK
      case RELOAD
    }
    
    
    
    public enum CardType: String {
      case VISA
      case MC
      case AMEX
      case DISCOVER
      case DINERS_CLUB
      case JCB
      case MAESTRO
      case SOLO
      case LASER
      case CHINA_UNION_PAY
      case CARTE_BLANCHE
      case UNKNOWN
      case GIFT_CARD
      case EBT
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments6Credit)public class Credit: NSObject, NSCoding, Mappable {
      /// Unique identifier
      public var id: String?
      /// The order with which the credit is associated
      public var orderRef: CLVModels.Order.Order?
      /// Device which processed this credit
      public var device: CLVModels.Device.Device?
      /// The tender type associated with this payment, e.g. credit card, cash, etc.
      public var tender: CLVModels.Base.Tender?
      /// The employee who processed the payment
      public var employee: CLVModels.Employees.Employee?
      /// Customer who received the credit/refund
      public var customers: CLVModels.Customers.Customer?
      /// Amount paid
      public var amount: Int?
      /// Amount paid in tax
      public var taxAmount: Int?
      public var taxRates: [CLVModels.Payments.TaxableAmountRate]?
      /// Time payment was recorded on server
      public var createdTime: Date?
      public var clientCreatedTime: Date?
      /// Information about the card used for credit/debit card payments
      public var cardTransaction: CLVModels.Payments.CardTransaction?
      public var voided: Bool?
      public var voidReason: String?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(id, forKey: "id")
        aCoder.encode(orderRef, forKey: "orderRef")
        aCoder.encode(device, forKey: "device")
        aCoder.encode(tender, forKey: "tender")
        aCoder.encode(employee, forKey: "employee")
        aCoder.encode(customers, forKey: "customers")
        aCoder.encode(amount, forKey: "amount")
        aCoder.encode(taxAmount, forKey: "taxAmount")
        aCoder.encode(taxRates, forKey: "taxRates")
        aCoder.encode(createdTime, forKey: "createdTime")
        aCoder.encode(clientCreatedTime, forKey: "clientCreatedTime")
        aCoder.encode(cardTransaction, forKey: "cardTransaction")
        aCoder.encode(voided, forKey: "voided")
        aCoder.encode(voidReason, forKey: "voidReason")
      }
      
      required public init(coder aDecoder: NSCoder) {
        id = aDecoder.decodeObject(forKey: "id") as? String
        orderRef = aDecoder.decodeObject(forKey: "orderRef") as? CLVModels.Order.Order
        device = aDecoder.decodeObject(forKey: "device") as? CLVModels.Device.Device
        tender = aDecoder.decodeObject(forKey: "tender") as? CLVModels.Base.Tender
        employee = aDecoder.decodeObject(forKey: "employee") as? CLVModels.Employees.Employee
        customers = aDecoder.decodeObject(forKey: "customers") as? CLVModels.Customers.Customer
        amount = aDecoder.decodeObject(forKey: "amount") as? Int
        taxAmount = aDecoder.decodeObject(forKey: "taxAmount") as? Int
        taxRates = aDecoder.decodeObject(forKey: "taxRates") as? [CLVModels.Payments.TaxableAmountRate]
        createdTime = aDecoder.decodeObject(forKey: "createdTime") as? Date
        clientCreatedTime = aDecoder.decodeObject(forKey: "clientCreatedTime") as? Date
        cardTransaction = aDecoder.decodeObject(forKey: "cardTransaction") as? CLVModels.Payments.CardTransaction
        voided = aDecoder.decodeObject(forKey: "voided") as? Bool
        voidReason = aDecoder.decodeObject(forKey: "voidReason") as? String
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        id <- map["id"]
        orderRef <- map["orderRef"]
        device <- map["device"]
        tender <- map["tender"]
        employee <- map["employee"]
        customers <- map["customers"]
        amount <- map["amount"]
        taxAmount <- map["taxAmount"]
        taxRates <- map["taxRates.elements"]
        createdTime <- (map["createdTime"], CLVDateTransform())
        clientCreatedTime <- (map["clientCreatedTime"], CLVDateTransform())
        cardTransaction <- map["cardTransaction"]
        voided <- map["voided"]
        voidReason <- map["voidReason"]
      }
    }
    
    
    
    public enum Currency: String {
      case USD
      case GBP
      case EUR
    }
    
    
    
    public enum CvmResult: String {
      case NO_CVM_REQUIRED
      case SIGNATURE
      case PIN
      case ONLINE_PIN
      case SIGNATURE_AND_PIN
      case CVM_FAILED
      case DEVICE
    }
    
    
    
    public enum CVVResult: String {
      case SUCCESS
      case FAILURE
      case NOT_PROCESSED
      case NOT_PRESENT
    }
    
    public enum DataEntryLocation: String {
        case ON_SCREEN
        case ON_PAPER
        case NONE
    }
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments10GatewayTxs)public class GatewayTxs: NSObject, NSCoding, Mappable {
      public var merchantGatewayId: Int?
      public var clientId: String?
      public var amount: Int?
      public var adjustAmount: Int?
      public var taxAmount: Int?
      public var tipAmount: Int?
      public var currency: CLVModels.Payments.Currency? = nil
      public var state: CLVModels.Payments.GatewayTxState? = nil
      public var retries: Int?
      public var type_: CLVModels.Payments.GatewayTxType? = nil
      public var entryType: CLVModels.Payments.CardEntryType? = nil
      public var responseCode: String?
      public var responseMessage: String?
      public var first4: String?
      public var last4: String?
      public var cardType: CLVModels.Payments.CardType? = nil
      public var refnum: String?
      public var token: String?
      public var authcode: String?
      public var employeeId: String?
      public var extra: String?
      public var captured: Bool?
      public var swiperSerial: String?
      public var ksnPrefix: String?
      public var createdTime: Date?
      public var modifiedTime: Date?
      public var refundId: Int?
      public var paymentRefundId: Int?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(merchantGatewayId, forKey: "merchantGatewayId")
        aCoder.encode(clientId, forKey: "clientId")
        aCoder.encode(amount, forKey: "amount")
        aCoder.encode(adjustAmount, forKey: "adjustAmount")
        aCoder.encode(taxAmount, forKey: "taxAmount")
        aCoder.encode(tipAmount, forKey: "tipAmount")
        aCoder.encode(currency?.rawValue, forKey: "currency")
        aCoder.encode(state?.rawValue, forKey: "state")
        aCoder.encode(retries, forKey: "retries")
        aCoder.encode(type_?.rawValue, forKey: "type_")
        aCoder.encode(entryType?.rawValue, forKey: "entryType")
        aCoder.encode(responseCode, forKey: "responseCode")
        aCoder.encode(responseMessage, forKey: "responseMessage")
        aCoder.encode(first4, forKey: "first4")
        aCoder.encode(last4, forKey: "last4")
        aCoder.encode(cardType?.rawValue, forKey: "cardType")
        aCoder.encode(refnum, forKey: "refnum")
        aCoder.encode(token, forKey: "token")
        aCoder.encode(authcode, forKey: "authcode")
        aCoder.encode(employeeId, forKey: "employeeId")
        aCoder.encode(extra, forKey: "extra")
        aCoder.encode(captured, forKey: "captured")
        aCoder.encode(swiperSerial, forKey: "swiperSerial")
        aCoder.encode(ksnPrefix, forKey: "ksnPrefix")
        aCoder.encode(createdTime, forKey: "createdTime")
        aCoder.encode(modifiedTime, forKey: "modifiedTime")
        aCoder.encode(refundId, forKey: "refundId")
        aCoder.encode(paymentRefundId, forKey: "paymentRefundId")
      }
      
      required public init(coder aDecoder: NSCoder) {
        merchantGatewayId = aDecoder.decodeObject(forKey: "merchantGatewayId") as? Int
        clientId = aDecoder.decodeObject(forKey: "clientId") as? String
        amount = aDecoder.decodeObject(forKey: "amount") as? Int
        adjustAmount = aDecoder.decodeObject(forKey: "adjustAmount") as? Int
        taxAmount = aDecoder.decodeObject(forKey: "taxAmount") as? Int
        tipAmount = aDecoder.decodeObject(forKey: "tipAmount") as? Int
        if let currencyString = aDecoder.decodeObject(forKey: "currency") as? String {
            currency = CLVModels.Payments.Currency(rawValue: currencyString)
        }
        if let stateString = aDecoder.decodeObject(forKey: "state") as? String {
            state = CLVModels.Payments.GatewayTxState(rawValue: stateString)
        }
        retries = aDecoder.decodeObject(forKey: "retries") as? Int
        if let typeString = aDecoder.decodeObject(forKey: "type_") as? String {
            type_ = CLVModels.Payments.GatewayTxType(rawValue: typeString)
        }
        if let entryTypeString = aDecoder.decodeObject(forKey: "entryType") as? String {
            entryType = CLVModels.Payments.CardEntryType(rawValue: entryTypeString)
        }
        responseCode = aDecoder.decodeObject(forKey: "responseCode") as? String
        responseMessage = aDecoder.decodeObject(forKey: "responseMessage") as? String
        first4 = aDecoder.decodeObject(forKey: "first4") as? String
        last4 = aDecoder.decodeObject(forKey: "last4") as? String
        if let cardTypeString = aDecoder.decodeObject(forKey: "cardType") as? String {
            cardType = CLVModels.Payments.CardType(rawValue: cardTypeString)
        }
        refnum = aDecoder.decodeObject(forKey: "refnum") as? String
        token = aDecoder.decodeObject(forKey: "token") as? String
        authcode = aDecoder.decodeObject(forKey: "authcode") as? String
        employeeId = aDecoder.decodeObject(forKey: "employeeId") as? String
        extra = aDecoder.decodeObject(forKey: "extra") as? String
        captured = aDecoder.decodeObject(forKey: "captured") as? Bool
        swiperSerial = aDecoder.decodeObject(forKey: "swiperSerial") as? String
        ksnPrefix = aDecoder.decodeObject(forKey: "ksnPrefix") as? String
        createdTime = aDecoder.decodeObject(forKey: "createdTime") as? Date
        modifiedTime = aDecoder.decodeObject(forKey: "modifiedTime") as? Date
        refundId = aDecoder.decodeObject(forKey: "refundId") as? Int
        paymentRefundId = aDecoder.decodeObject(forKey: "paymentRefundId") as? Int
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        merchantGatewayId <- map["merchantGatewayId"]
        clientId <- map["clientId"]
        amount <- map["amount"]
        adjustAmount <- map["adjustAmount"]
        taxAmount <- map["taxAmount"]
        tipAmount <- map["tipAmount"]
        currency <- map["currency"]
        state <- map["state"]
        retries <- map["retries"]
        type_ <- map["type"]
        entryType <- map["entryType"]
        responseCode <- map["responseCode"]
        responseMessage <- map["responseMessage"]
        first4 <- map["first4"]
        last4 <- map["last4"]
        cardType <- map["cardType"]
        refnum <- map["refnum"]
        token <- map["token"]
        authcode <- map["authcode"]
        employeeId <- map["employeeId"]
        extra <- map["extra"]
        captured <- map["captured"]
        swiperSerial <- map["swiperSerial"]
        ksnPrefix <- map["ksnPrefix"]
        createdTime <- (map["createdTime"], CLVDateTransform())
        modifiedTime <- (map["modifiedTime"], CLVDateTransform())
        refundId <- map["refundId"]
        paymentRefundId <- map["paymentRefundId"]
      }
    }
    
    
    
    public enum GatewayTxState: String {
      case INITIATED
      case INITIATED_ON_AUTH
      case ACKNOWLEDGED
      case CONNECT_FAILED
      case TIMEOUT
      case FAILED
      case REVERSE_INITIATED
      case REVERSE_INITIATED_ON_AUTH
      case REVERSED
      case REVERSAL_FAILED
    }
    
    
    
    public enum GatewayTxType: String {
      case AUTH
      case PREAUTH
      case PREAUTHCAPTURE
      case ADJUST
      case VOID
      case VOIDRETURN
      case RETURN
      case REFUND
      case NAKEDREFUND
      case GETBALANCE
      case BATCHCLOSE
      case ACTIVATE
      case BALANCE_LOCK
      case LOAD
      case CASHOUT
      case CASHOUT_ACTIVE_STATUS
      case REDEMPTION
      case REDEMPTION_UNLOCK
      case RELOAD
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments8GiftCard)public class GiftCard: NSObject, NSCoding, Mappable {
      /// Track 2 Card Data
      public var track2: String?
      /// Embossed Card Number
      public var cardNumber: String?
      /// Was Account Number Manually Entered
      public var isManuallyEntered: Bool?
      public var deviceSerial: String?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(track2, forKey: "track2")
        aCoder.encode(cardNumber, forKey: "cardNumber")
        aCoder.encode(isManuallyEntered, forKey: "isManuallyEntered")
        aCoder.encode(deviceSerial, forKey: "deviceSerial")
      }
      
      required public init(coder aDecoder: NSCoder) {
        track2 = aDecoder.decodeObject(forKey: "track2") as? String
        cardNumber = aDecoder.decodeObject(forKey: "cardNumber") as? String
        isManuallyEntered = aDecoder.decodeObject(forKey: "isManuallyEntered") as? Bool
        deviceSerial = aDecoder.decodeObject(forKey: "deviceSerial") as? String
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        track2 <- map["track2"]
        cardNumber <- map["cardNumber"]
        isManuallyEntered <- map["isManuallyEntered"]
        deviceSerial <- map["deviceSerial"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments16GiftCardResponse)public class GiftCardResponse: NSObject, NSCoding, Mappable {
      public var txType: CLVModels.Payments.TxType? = nil
      public var state: CLVModels.Payments.GiftCardState? = nil
      /// Transaction Amount
      public var requestAmount: Int?
      public var payment: CLVModels.Payments.Payment?
      public var responseMessage: String?
      public var requestSuccessful: Bool?
      public var accountNumber: String?
      public var giftCardTxUuid: String?
      public var transactionId: String?
      public var referenceUuid: String?
      public var authCode: String?
      public var begBal: Int?
      public var endBal: Int?
      public var holdBal: Int?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(txType?.rawValue, forKey: "txType")
        aCoder.encode(state?.rawValue, forKey: "state")
        aCoder.encode(requestAmount, forKey: "requestAmount")
        aCoder.encode(payment, forKey: "payment")
        aCoder.encode(responseMessage, forKey: "responseMessage")
        aCoder.encode(requestSuccessful, forKey: "requestSuccessful")
        aCoder.encode(accountNumber, forKey: "accountNumber")
        aCoder.encode(giftCardTxUuid, forKey: "giftCardTxUuid")
        aCoder.encode(transactionId, forKey: "transactionId")
        aCoder.encode(referenceUuid, forKey: "referenceUuid")
        aCoder.encode(authCode, forKey: "authCode")
        aCoder.encode(begBal, forKey: "begBal")
        aCoder.encode(endBal, forKey: "endBal")
        aCoder.encode(holdBal, forKey: "holdBal")
      }
      
      required public init(coder aDecoder: NSCoder) {
        if let txTypeString = aDecoder.decodeObject(forKey: "txType") as? String {
            txType = CLVModels.Payments.TxType(rawValue: txTypeString)
        }
        if let stateString = aDecoder.decodeObject(forKey: "state") as? String {
            state = CLVModels.Payments.GiftCardState(rawValue: stateString)
        }
        requestAmount = aDecoder.decodeObject(forKey: "requestAmount") as? Int
        payment = aDecoder.decodeObject(forKey: "payment") as? CLVModels.Payments.Payment
        responseMessage = aDecoder.decodeObject(forKey: "responseMessage") as? String
        requestSuccessful = aDecoder.decodeObject(forKey: "requestSuccessful") as? Bool
        accountNumber = aDecoder.decodeObject(forKey: "accountNumber") as? String
        giftCardTxUuid = aDecoder.decodeObject(forKey: "giftCardTxUuid") as? String
        transactionId = aDecoder.decodeObject(forKey: "transactionId") as? String
        referenceUuid = aDecoder.decodeObject(forKey: "referenceUuid") as? String
        authCode = aDecoder.decodeObject(forKey: "authCode") as? String
        begBal = aDecoder.decodeObject(forKey: "begBal") as? Int
        endBal = aDecoder.decodeObject(forKey: "endBal") as? Int
        holdBal = aDecoder.decodeObject(forKey: "holdBal") as? Int
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        txType <- map["txType"]
        state <- map["state"]
        requestAmount <- map["requestAmount"]
        payment <- map["payment"]
        responseMessage <- map["responseMessage"]
        requestSuccessful <- map["requestSuccessful"]
        accountNumber <- map["accountNumber"]
        giftCardTxUuid <- map["giftCardTxUuid"]
        transactionId <- map["transactionId"]
        referenceUuid <- map["referenceUuid"]
        authCode <- map["authCode"]
        begBal <- map["begBal"]
        endBal <- map["endBal"]
        holdBal <- map["holdBal"]
      }
    }
    
    
    
    public enum GiftCardState: String {
      case INVALID
      case ACTIVATED
      case INACTIVE
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments19GiftCardTransaction)public class GiftCardTransaction: NSObject, NSCoding, Mappable {
      /// Transaction Amount
      public var amount: Int?
      /// Tax Amount
      public var taxAmount: Int?
      public var orderId: String?
      /// Gift Card
      public var card: CLVModels.Payments.GiftCard?
      public var paymentIds: [String]?
      public var ignorePayment: Bool?
      public var serviceChargeAmount: CLVModels.Payments.ServiceChargeAmount?
      public var taxableAmountRates: [CLVModels.Payments.TaxableAmountRate]?
      /// Payments that were made for this line item
      public var lineItems: [CLVModels.Payments.LineItemPayment]?
      public var employeeId: String?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(amount, forKey: "amount")
        aCoder.encode(taxAmount, forKey: "taxAmount")
        aCoder.encode(orderId, forKey: "orderId")
        aCoder.encode(card, forKey: "card")
        aCoder.encode(paymentIds, forKey: "paymentIds")
        aCoder.encode(ignorePayment, forKey: "ignorePayment")
        aCoder.encode(serviceChargeAmount, forKey: "serviceChargeAmount")
        aCoder.encode(taxableAmountRates, forKey: "taxableAmountRates")
        aCoder.encode(lineItems, forKey: "lineItems")
        aCoder.encode(employeeId, forKey: "employeeId")
      }
      
      required public init(coder aDecoder: NSCoder) {
        amount = aDecoder.decodeObject(forKey: "amount") as? Int
        taxAmount = aDecoder.decodeObject(forKey: "taxAmount") as? Int
        orderId = aDecoder.decodeObject(forKey: "orderId") as? String
        card = aDecoder.decodeObject(forKey: "card") as? CLVModels.Payments.GiftCard
        paymentIds = aDecoder.decodeObject(forKey: "paymentIds") as? [String]
        ignorePayment = aDecoder.decodeObject(forKey: "ignorePayment") as? Bool
        serviceChargeAmount = aDecoder.decodeObject(forKey: "serviceChargeAmount") as? CLVModels.Payments.ServiceChargeAmount
        taxableAmountRates = aDecoder.decodeObject(forKey: "taxableAmountRates") as? [CLVModels.Payments.TaxableAmountRate]
        lineItems = aDecoder.decodeObject(forKey: "lineItems") as? [CLVModels.Payments.LineItemPayment]
        employeeId = aDecoder.decodeObject(forKey: "employeeId") as? String
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        amount <- map["amount"]
        taxAmount <- map["taxAmount"]
        orderId <- map["orderId"]
        card <- map["card"]
        paymentIds <- map["paymentIds"]
        ignorePayment <- map["ignorePayment"]
        serviceChargeAmount <- map["serviceChargeAmount"]
        taxableAmountRates <- map["taxableAmountRates.elements"]
        lineItems <- map["lineItems.elements"]
        employeeId <- map["employeeId"]
      }
    }
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments7DCCInfo)public class DCCInfo: NSObject, NSCoding, Mappable {
        
        /// Inquiry Rate ID (IPG)
        public var inquiryRateId: Int?
        
        /// Flag indicating whether DCC was applied on this txn
        public var dccApplied: Bool?
        
        /// Foreign currency code
        public var foreignCurrencyCode: String?
        
        /// Foreign (transaction) amount
        public var foreignAmount: Int?
        
        /// Exchange Rate
        public var exchangeRate: Double?
        
        /// Margin Rate Percentage
        public var marginRatePercentage: String?
        
        /// Exchange Rate Source Name
        public var exchangeRateSourceName: String?
        
        /// Exchange Rate Source Timestamp
        public var exchangeRateSourceTimeStamp: String?
        
        
        public func encode(with aCoder: NSCoder) {
            aCoder.encode(inquiryRateId, forKey: "inquiryRateId")
            aCoder.encode(dccApplied, forKey: "dccApplied")
            aCoder.encode(foreignCurrencyCode, forKey: "foreignCurrencyCode")
            aCoder.encode(foreignAmount, forKey: "foreignAmount")
            aCoder.encode(exchangeRate, forKey: "exchangeRate")
            aCoder.encode(marginRatePercentage, forKey: "marginRatePercentage")
            aCoder.encode(exchangeRateSourceName, forKey: "exchangeRateSourceName")
            aCoder.encode(exchangeRateSourceTimeStamp, forKey: "exchangeRateSourceTimeStamp")
        }
        
        required public init(coder aDecoder: NSCoder) {
            inquiryRateId = aDecoder.decodeObject(forKey: "inquiryRateId") as? Int
            dccApplied = aDecoder.decodeObject(forKey: "dccApplied") as? Bool
            foreignCurrencyCode = aDecoder.decodeObject(forKey: "foreignCurrencyCode") as? String
            foreignAmount = aDecoder.decodeObject(forKey: "foreignAmount") as? Int
            exchangeRate = aDecoder.decodeObject(forKey: "exchangeRate") as? Double
            marginRatePercentage = aDecoder.decodeObject(forKey: "marginRatePercentage") as? String
            exchangeRateSourceName = aDecoder.decodeObject(forKey: "exchangeRateSourceName") as? String
            exchangeRateSourceTimeStamp = aDecoder.decodeObject(forKey: "exchangeRateSourceTimeStamp") as? String
        }
        
        override public init() {}
        
        // Mappable
        required public init?(map:Map) {}
        
        public func mapping(map:Map) {
            inquiryRateId <- map["inquiryRateId"]
            dccApplied <- map["dccApplied"]
            foreignCurrencyCode <- map["foreignCurrencyCode"]
            foreignAmount <- map["foreignAmount"]
            exchangeRate <- map["exchangeRate"]
            marginRatePercentage <- map["marginRatePercentage"]
            exchangeRateSourceName <- map["exchangeRateSourceName"]
            exchangeRateSourceTimeStamp <- map["exchangeRateSourceTimeStamp"]
        }
    }
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments10GermanInfo)public class GermanInfo: NSObject, NSCoding, Mappable {
        
        public var cardTrack2: String?
        
        public var cardSequenceNumber: String?
        
        public var transactionCaseGermany: String?
        
        public var transactionTypeGermany: String?
        
        public var terminalID: String?
        
        public var traceNumber: String?
        
        public var oldTraceNumber: String?
        
        public var receiptNumber: String?
        
        public var transactionAID: String?
        
        public var transactionMSApp: String?
        
        public var transactionScriptResults: String?
        
        public var receiptType: String?
        
        public var customerTransactionDOLValues: String?
        
        public var merchantTransactionDOLValues: String?
        
        public var merchantJournalDOL: String?
        
        public var merchantJournalDOLValues: String?
        
        public var configMerchantId: String?
        
        public var configProductLabel: String?
        
        public var hostResponseAidParBMP53: String?
        
        public var hostResponsePrintDataBM60: String?
        
        public func encode(with aCoder: NSCoder) {
            aCoder.encode(cardTrack2, forKey: "cardTrack2")
            aCoder.encode(cardSequenceNumber, forKey: "cardSequenceNumber")
            aCoder.encode(transactionCaseGermany, forKey: "transactionCaseGermany")
            aCoder.encode(transactionTypeGermany, forKey: "transactionTypeGermany")
            aCoder.encode(terminalID, forKey: "terminalID")
            aCoder.encode(traceNumber, forKey: "traceNumber")
            aCoder.encode(oldTraceNumber, forKey: "oldTraceNumber")
            aCoder.encode(receiptNumber, forKey: "receiptNumber")
            aCoder.encode(transactionAID, forKey: "transactionAID")
            aCoder.encode(transactionMSApp, forKey: "transactionMSApp")
            aCoder.encode(transactionScriptResults, forKey: "transactionScriptResults")
            aCoder.encode(receiptType, forKey: "receiptType")
            aCoder.encode(customerTransactionDOLValues, forKey: "customerTransactionDOLValues")
            aCoder.encode(merchantTransactionDOLValues, forKey: "merchantTransactionDOLValues")
            aCoder.encode(merchantJournalDOL, forKey: "merchantJournalDOL")
            aCoder.encode(merchantJournalDOLValues, forKey: "merchantJournalDOLValues")
            aCoder.encode(configMerchantId, forKey: "configMerchantId")
            aCoder.encode(configProductLabel, forKey: "configProductLabel")
            aCoder.encode(hostResponseAidParBMP53, forKey: "hostResponseAidParBMP53")
            aCoder.encode(hostResponsePrintDataBM60, forKey: "hostResponsePrintDataBM60")
        }
        
        required public init(coder aDecoder: NSCoder) {
            cardTrack2 = aDecoder.decodeObject(forKey: "cardTrack2") as? String
            cardSequenceNumber = aDecoder.decodeObject(forKey: "cardSequenceNumber") as? String
            transactionCaseGermany = aDecoder.decodeObject(forKey: "transactionCaseGermany") as? String
            transactionTypeGermany = aDecoder.decodeObject(forKey: "transactionTypeGermany") as? String
            terminalID = aDecoder.decodeObject(forKey: "terminalID") as? String
            traceNumber = aDecoder.decodeObject(forKey: "traceNumber") as? String
            oldTraceNumber = aDecoder.decodeObject(forKey: "oldTraceNumber") as? String
            receiptNumber = aDecoder.decodeObject(forKey: "receiptNumber") as? String
            transactionAID = aDecoder.decodeObject(forKey: "transactionAID") as? String
            transactionMSApp = aDecoder.decodeObject(forKey: "transactionMSApp") as? String
            transactionScriptResults = aDecoder.decodeObject(forKey: "transactionScriptResults") as? String
            receiptType = aDecoder.decodeObject(forKey: "receiptType") as? String
            customerTransactionDOLValues = aDecoder.decodeObject(forKey: "customerTransactionDOLValues") as? String
            merchantTransactionDOLValues = aDecoder.decodeObject(forKey: "merchantTransactionDOLValues") as? String
            merchantJournalDOL = aDecoder.decodeObject(forKey: "merchantJournalDOL") as? String
            merchantJournalDOLValues = aDecoder.decodeObject(forKey: "merchantJournalDOLValues") as? String
            configMerchantId = aDecoder.decodeObject(forKey: "configMerchantId") as? String
            configProductLabel = aDecoder.decodeObject(forKey: "configProductLabel") as? String
            hostResponseAidParBMP53 = aDecoder.decodeObject(forKey: "hostResponseAidParBMP53") as? String
            hostResponsePrintDataBM60 = aDecoder.decodeObject(forKey: "hostResponsePrintDataBM60") as? String
        }
        
        override public init() {}
        
        // Mappable
        required public init?(map:Map) {}
        
        public func mapping(map:Map) {
            cardTrack2 <- map["cardTrack2"]
            cardSequenceNumber <- map["cardSequenceNumber"]
            transactionCaseGermany <- map["transactionCaseGermany"]
            transactionTypeGermany <- map["transactionTypeGermany"]
            terminalID <- map["terminalID"]
            traceNumber <- map["traceNumber"]
            oldTraceNumber <- map["oldTraceNumber"]
            receiptNumber <- map["receiptNumber"]
            transactionAID <- map["transactionAID"]
            transactionMSApp <- map["transactionMSApp"]
            transactionScriptResults <- map["transactionScriptResults"]
            receiptType <- map["receiptType"]
            customerTransactionDOLValues <- map["customerTransactionDOLValues"]
            merchantTransactionDOLValues <- map["merchantTransactionDOLValues"]
            merchantJournalDOL <- map["merchantJournalDOL"]
            merchantJournalDOLValues <- map["merchantJournalDOLValues"]
            configMerchantId <- map["configMerchantId"]
            configProductLabel <- map["configProductLabel"]
            hostResponseAidParBMP53 <- map["hostResponseAidParBMP53"]
            hostResponsePrintDataBM60 <- map["hostResponsePrintDataBM60"]
        }
    }
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments15LineItemPayment)public class LineItemPayment: NSObject, NSCoding, Mappable {
      /// Unique identifier; TBD this is confusing because it's used as either line item id or payment id
      public var id: String?
      /// The line item with which the line item payment is associated
      public var lineItemRef: CLVModels.Order.LineItem?
      /// The payment with which the line item payment is associated
      public var paymentRef: CLVModels.Payments.Payment?
      /// Percent of this line item covered by this payment
      public var percentage: Int?
      /// Bin this line item payment was for
      public var binName: String?
      /// Payment has been refunded
      public var refunded: Bool?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(id, forKey: "id")
        aCoder.encode(lineItemRef, forKey: "lineItemRef")
        aCoder.encode(paymentRef, forKey: "paymentRef")
        aCoder.encode(percentage, forKey: "percentage")
        aCoder.encode(binName, forKey: "binName")
        aCoder.encode(refunded, forKey: "refunded")
      }
      
      required public init(coder aDecoder: NSCoder) {
        id = aDecoder.decodeObject(forKey: "id") as? String
        lineItemRef = aDecoder.decodeObject(forKey: "lineItemRef") as? CLVModels.Order.LineItem
        paymentRef = aDecoder.decodeObject(forKey: "paymentRef") as? CLVModels.Payments.Payment
        percentage = aDecoder.decodeObject(forKey: "percentage") as? Int
        binName = aDecoder.decodeObject(forKey: "binName") as? String
        refunded = aDecoder.decodeObject(forKey: "refunded") as? Bool
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        id <- map["id"]
        lineItemRef <- map["lineItemRef"]
        paymentRef <- map["paymentRef"]
        percentage <- map["percentage"]
        binName <- map["binName"]
        refunded <- map["refunded"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments7Payment)public class Payment: NSObject, NSCoding, Mappable {
        /// Unique identifier
        public var id: String?
        
        /// The order with which the payment is associated
        public var order: CLVModels.Base.Reference?
        
        /// Device which processed the transaction for this payment
        public var device: CLVModels.Base.Reference?
        
        /// The tender type associated with this payment, e.g. credit card, cash, etc.
        public var tender: CLVModels.Base.Tender?
        
        /// Total amount paid
        public var amount: Int?
        
        /// Amount paid in tips
        public var tipAmount: Int?
        
        /// Amount paid in tax
        public var taxAmount: Int?
        
        /// Amount given back in a cash back transaction
        public var cashbackAmount: Int?
        
        /// Amount of cash given by the customer
        public var cashTendered: Int?
        
        public var externalPaymentId: String?
        
        /// The employee who processed the payment
        public var employee: CLVModels.Base.Reference?
        
        /// Time payment was recorded on server
        public var createdTime: Date?
        
        public var clientCreatedTime: Date?
        
        /// Last modified time of the payment
        public var modifiedTime: Date?
        
        public var offline: Bool?
        
        public var result: CLVModels.Payments.Result? = nil
        
        /// Information about the card used for credit/debit card payments
        public var cardTransaction: CLVModels.Payments.CardTransaction?
        
        /// Amount record as a service charge
        public var serviceCharge: CLVModels.Payments.ServiceChargeAmount?
        
        public var taxRates: [CLVModels.Payments.PaymentTaxRate]?
        
        public var refunds: [CLVModels.Payments.Refund]?
        
        public var note: String?
        
        public var lineItemPayments: [CLVModels.Payments.LineItemPayment]?
        
        /// If voided, the reason why (when available)
        public var voidReason: CLVModels.Order.VoidReason? = nil
        
        /// Dynamic Currency Conversion information
        public var dccInfo: CLVModels.Payments.DCCInfo?
        
        /// Per transaction settings for the payment
        public var transactionSettings: CLVModels.Payments.TransactionSettings?
        
        /// German region-specific information
        public var germanInfo: CLVModels.Payments.GermanInfo?
        
        /// Tracking information for the app that created this payment.
        public var appTracking: CLVModels.Apps.AppTracking?
        
        public func encode(with aCoder: NSCoder) {
            aCoder.encode(id, forKey: "id")
            aCoder.encode(order, forKey: "order")
            aCoder.encode(device, forKey: "device")
            aCoder.encode(tender, forKey: "tender")
            aCoder.encode(amount, forKey: "amount")
            aCoder.encode(tipAmount, forKey: "tipAmount")
            aCoder.encode(taxAmount, forKey: "taxAmount")
            aCoder.encode(cashbackAmount, forKey: "cashbackAmount")
            aCoder.encode(cashTendered, forKey: "cashTendered")
            aCoder.encode(externalPaymentId, forKey: "externalPaymentId")
            aCoder.encode(employee, forKey: "employee")
            aCoder.encode(createdTime, forKey: "createdTime")
            aCoder.encode(clientCreatedTime, forKey: "clientCreatedTime")
            aCoder.encode(modifiedTime, forKey: "modifiedTime")
            aCoder.encode(offline, forKey: "offline")
            aCoder.encode(result?.rawValue, forKey: "result")
            aCoder.encode(cardTransaction, forKey: "cardTransaction")
            aCoder.encode(serviceCharge, forKey: "serviceCharge")
            aCoder.encode(taxRates, forKey: "taxRates")
            aCoder.encode(refunds, forKey: "refunds")
            aCoder.encode(note, forKey: "note")
            aCoder.encode(lineItemPayments, forKey: "lineItemPayments")
            aCoder.encode(voidReason?.rawValue, forKey: "voidReason")
            aCoder.encode(dccInfo, forKey: "dccInfo")
            aCoder.encode(transactionSettings, forKey: "transactionSettings")
            aCoder.encode(germanInfo, forKey: "germanInfo")
            aCoder.encode(appTracking, forKey: "appTracking")
        }
        
        required public init(coder aDecoder: NSCoder) {
            id = aDecoder.decodeObject(forKey: "id") as? String
            order = aDecoder.decodeObject(forKey: "order") as? CLVModels.Base.Reference
            device = aDecoder.decodeObject(forKey: "device") as? CLVModels.Base.Reference
            tender = aDecoder.decodeObject(forKey: "tender") as? CLVModels.Base.Tender
            amount = aDecoder.decodeObject(forKey: "amount") as? Int
            tipAmount = aDecoder.decodeObject(forKey: "tipAmount") as? Int
            taxAmount = aDecoder.decodeObject(forKey: "taxAmount") as? Int
            cashbackAmount = aDecoder.decodeObject(forKey: "cashbackAmount") as? Int
            cashTendered = aDecoder.decodeObject(forKey: "cashTendered") as? Int
            externalPaymentId = aDecoder.decodeObject(forKey: "externalPaymentId") as? String
            employee = aDecoder.decodeObject(forKey: "employee") as? CLVModels.Base.Reference
            createdTime = aDecoder.decodeObject(forKey: "createdTime") as? Date
            clientCreatedTime = aDecoder.decodeObject(forKey: "clientCreatedTime") as? Date
            modifiedTime = aDecoder.decodeObject(forKey: "modifiedTime") as? Date
            offline = aDecoder.decodeObject(forKey: "offline") as? Bool
            if let resultString = aDecoder.decodeObject(forKey: "result") as? String {
                result = CLVModels.Payments.Result(rawValue: resultString)
            }
            cardTransaction = aDecoder.decodeObject(forKey: "cardTransaction") as? CLVModels.Payments.CardTransaction
            serviceCharge = aDecoder.decodeObject(forKey: "serviceCharge") as? CLVModels.Payments.ServiceChargeAmount
            taxRates = aDecoder.decodeObject(forKey: "taxRates") as? [CLVModels.Payments.PaymentTaxRate]
            refunds = aDecoder.decodeObject(forKey: "refunds") as? [CLVModels.Payments.Refund]
            note = aDecoder.decodeObject(forKey: "note") as? String
            lineItemPayments = aDecoder.decodeObject(forKey: "lineItemPayments") as? [CLVModels.Payments.LineItemPayment]
            if let voidReasonString = aDecoder.decodeObject(forKey: "voidReason") as? String {
                voidReason = CLVModels.Order.VoidReason(rawValue: voidReasonString)
            }
            dccInfo = aDecoder.decodeObject(forKey: "dccInfo") as? CLVModels.Payments.DCCInfo
            transactionSettings = aDecoder.decodeObject(forKey: "transactionSettings") as? CLVModels.Payments.TransactionSettings
            germanInfo = aDecoder.decodeObject(forKey: "germanInfo") as? CLVModels.Payments.GermanInfo
            appTracking = aDecoder.decodeObject(forKey: "appTracking") as? CLVModels.Apps.AppTracking
        }
        
        override public init() {}
        
        // Mappable
        
        required public init?(map:Map) {}
        
        public func mapping(map:Map) {
            id <- map["id"]
            order <- map["order"]
            device <- map["device"]
            tender <- map["tender"]
            amount <- map["amount"]
            tipAmount <- map["tipAmount"]
            taxAmount <- map["taxAmount"]
            cashbackAmount <- map["cashbackAmount"]
            cashTendered <- map["cashTendered"]
            externalPaymentId <- map["externalPaymentId"]
            employee <- map["employee"]
            createdTime <- (map["createdTime"], CLVDateTransform())
            clientCreatedTime <- (map["clientCreatedTime"], CLVDateTransform())
            modifiedTime <- (map["modifiedTime"], CLVDateTransform())
            offline <- map["offline"]
            result <- map["result"]
            cardTransaction <- map["cardTransaction"]
            serviceCharge <- map["serviceCharge"]
            taxRates <- map["taxRates.elements"]
            refunds <- map["refunds.elements"]
            note <- map["note"]
            lineItemPayments <- map["lineItemPayments.elements"]
            voidReason <- map["voidReason"]
            dccInfo <- map["dccInfo"]
            transactionSettings <- map["transactionSettings"]
            germanInfo <- map["germanInfo"]
            appTracking <- map["appTracking"]
        }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments15PaymentResponse)public class PaymentResponse: NSObject, NSCoding, Mappable {
      public var requestSuccessful: Bool?
      public var responseErrorMessage: String?
      public var payment: CLVModels.Payments.Payment?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(requestSuccessful, forKey: "requestSuccessful")
        aCoder.encode(responseErrorMessage, forKey: "responseErrorMessage")
        aCoder.encode(payment, forKey: "payment")
      }
      
      required public init(coder aDecoder: NSCoder) {
        requestSuccessful = aDecoder.decodeObject(forKey: "requestSuccessful") as? Bool
        responseErrorMessage = aDecoder.decodeObject(forKey: "responseErrorMessage") as? String
        payment = aDecoder.decodeObject(forKey: "payment") as? CLVModels.Payments.Payment
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        requestSuccessful <- map["requestSuccessful"]
        responseErrorMessage <- map["responseErrorMessage"]
        payment <- map["payment"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments14PaymentTaxRate)public class PaymentTaxRate: NSObject, NSCoding, Mappable {
      public var id: String?
      /// The payment with which the payment tax rate is associated
      public var paymentRef: CLVModels.Payments.Payment?
      public var name: String?
      public var rate: Int?
      public var isDefault: Bool?
      public var taxableAmount: Int?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(id, forKey: "id")
        aCoder.encode(paymentRef, forKey: "paymentRef")
        aCoder.encode(name, forKey: "name")
        aCoder.encode(rate, forKey: "rate")
        aCoder.encode(isDefault, forKey: "isDefault")
        aCoder.encode(taxableAmount, forKey: "taxableAmount")
      }
      
      required public init(coder aDecoder: NSCoder) {
        id = aDecoder.decodeObject(forKey: "id") as? String
        paymentRef = aDecoder.decodeObject(forKey: "paymentRef") as? CLVModels.Payments.Payment
        name = aDecoder.decodeObject(forKey: "name") as? String
        rate = aDecoder.decodeObject(forKey: "rate") as? Int
        isDefault = aDecoder.decodeObject(forKey: "isDefault") as? Bool
        taxableAmount = aDecoder.decodeObject(forKey: "taxableAmount") as? Int
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        id <- map["id"]
        paymentRef <- map["paymentRef"]
        name <- map["name"]
        rate <- map["rate"]
        isDefault <- map["isDefault"]
        taxableAmount <- map["taxableAmount"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments6Refund)public class Refund: NSObject, NSCoding, Mappable {
      /// Unique identifier
      public var id: String?
      /// The order with which the refund is associated
      public var orderRef: CLVModels.Order.Order?
      /// Device which processed the transaction for this refund
      public var device: CLVModels.Device.Device?
      /// Total amount refunded, including tax
      public var amount: Int?
      /// Tax amount refunded
      public var taxAmount: Int?
      /// The time when the refund was recorded on the server
      public var createdTime: Date?
      /// The time when the refund was recorded on the client
      public var clientCreatedTime: Date?
      /// The payment with which the refund is associated
      public var payment: CLVModels.Payments.Payment?
      public var employee: CLVModels.Employees.Employee?
      public var lineItems: [CLVModels.Order.LineItem]?
      /// The tender type associated with this payment, e.g. credit card, cash, etc.
      public var overrideMerchantTender: CLVModels.Base.Tender?
      public var taxableAmountRates: [CLVModels.Payments.TaxableAmountRate]?
      public var serviceChargeAmount: CLVModels.Payments.ServiceChargeAmount?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(id, forKey: "id")
        aCoder.encode(orderRef, forKey: "orderRef")
        aCoder.encode(device, forKey: "device")
        aCoder.encode(amount, forKey: "amount")
        aCoder.encode(taxAmount, forKey: "taxAmount")
        aCoder.encode(createdTime, forKey: "createdTime")
        aCoder.encode(clientCreatedTime, forKey: "clientCreatedTime")
        aCoder.encode(payment, forKey: "payment")
        aCoder.encode(employee, forKey: "employee")
        aCoder.encode(lineItems, forKey: "lineItems")
        aCoder.encode(overrideMerchantTender, forKey: "overrideMerchantTender")
        aCoder.encode(taxableAmountRates, forKey: "taxableAmountRates")
        aCoder.encode(serviceChargeAmount, forKey: "serviceChargeAmount")
      }
      
      required public init(coder aDecoder: NSCoder) {
        id = aDecoder.decodeObject(forKey: "id") as? String
        orderRef = aDecoder.decodeObject(forKey: "orderRef") as? CLVModels.Order.Order
        device = aDecoder.decodeObject(forKey: "device") as? CLVModels.Device.Device
        amount = aDecoder.decodeObject(forKey: "amount") as? Int
        taxAmount = aDecoder.decodeObject(forKey: "taxAmount") as? Int
        createdTime = aDecoder.decodeObject(forKey: "createdTime") as? Date
        clientCreatedTime = aDecoder.decodeObject(forKey: "clientCreatedTime") as? Date
        payment = aDecoder.decodeObject(forKey: "payment") as? CLVModels.Payments.Payment
        employee = aDecoder.decodeObject(forKey: "employee") as? CLVModels.Employees.Employee
        lineItems = aDecoder.decodeObject(forKey: "lineItems") as? [CLVModels.Order.LineItem]
        overrideMerchantTender = aDecoder.decodeObject(forKey: "overrideMerchantTender") as? CLVModels.Base.Tender
        taxableAmountRates = aDecoder.decodeObject(forKey: "taxableAmountRates") as? [CLVModels.Payments.TaxableAmountRate]
        serviceChargeAmount = aDecoder.decodeObject(forKey: "serviceChargeAmount") as? CLVModels.Payments.ServiceChargeAmount
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        id <- map["id"]
        orderRef <- map["orderRef"]
        device <- map["device"]
        amount <- map["amount"]
        taxAmount <- map["taxAmount"]
        createdTime <- (map["createdTime"], CLVDateTransform())
        clientCreatedTime <- (map["clientCreatedTime"], CLVDateTransform())
        payment <- map["payment"]
        employee <- map["employee"]
        lineItems <- map["lineItems.elements"]
        overrideMerchantTender <- map["overrideMerchantTender"]
        taxableAmountRates <- map["taxableAmountRates.elements"]
        serviceChargeAmount <- map["serviceChargeAmount"]
      }
    }
    
    
    
    public enum Result: String {
      case SUCCESS
      case FAIL
      case INITIATED
      case VOIDED
      case VOIDING
      case AUTH
      case AUTH_COMPLETED
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments16ServerTotalStats)public class ServerTotalStats: NSObject, NSCoding, Mappable {
      /// Employee corresponding to these stats
      public var employeeId: String?
      public var employeeName: String?
      public var sales: CLVModels.Payments.BatchTotalType?
      public var refunds: CLVModels.Payments.BatchTotalType?
      public var net: CLVModels.Payments.BatchTotalType?
      public var giftCardLoads: CLVModels.Payments.BatchTotalType?
      public var giftCardCashOuts: CLVModels.Payments.BatchTotalType?
      public var tax: CLVModels.Payments.BatchTotalType?
      public var tips: CLVModels.Payments.BatchTotalType?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(employeeId, forKey: "employeeId")
        aCoder.encode(employeeName, forKey: "employeeName")
        aCoder.encode(sales, forKey: "sales")
        aCoder.encode(refunds, forKey: "refunds")
        aCoder.encode(net, forKey: "net")
        aCoder.encode(giftCardLoads, forKey: "giftCardLoads")
        aCoder.encode(giftCardCashOuts, forKey: "giftCardCashOuts")
        aCoder.encode(tax, forKey: "tax")
        aCoder.encode(tips, forKey: "tips")
      }
      
      required public init(coder aDecoder: NSCoder) {
        employeeId = aDecoder.decodeObject(forKey: "employeeId") as? String
        employeeName = aDecoder.decodeObject(forKey: "employeeName") as? String
        sales = aDecoder.decodeObject(forKey: "sales") as? CLVModels.Payments.BatchTotalType
        refunds = aDecoder.decodeObject(forKey: "refunds") as? CLVModels.Payments.BatchTotalType
        net = aDecoder.decodeObject(forKey: "net") as? CLVModels.Payments.BatchTotalType
        giftCardLoads = aDecoder.decodeObject(forKey: "giftCardLoads") as? CLVModels.Payments.BatchTotalType
        giftCardCashOuts = aDecoder.decodeObject(forKey: "giftCardCashOuts") as? CLVModels.Payments.BatchTotalType
        tax = aDecoder.decodeObject(forKey: "tax") as? CLVModels.Payments.BatchTotalType
        tips = aDecoder.decodeObject(forKey: "tips") as? CLVModels.Payments.BatchTotalType
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        employeeId <- map["employeeId"]
        employeeName <- map["employeeName"]
        sales <- map["sales"]
        refunds <- map["refunds"]
        net <- map["net"]
        giftCardLoads <- map["giftCardLoads"]
        giftCardCashOuts <- map["giftCardCashOuts"]
        tax <- map["tax"]
        tips <- map["tips"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments19ServiceChargeAmount)public class ServiceChargeAmount: NSObject, NSCoding, Mappable {
      public var id: String?
      public var name: String?
      public var amount: Int?
      /// The payment with which the payment tax rate is associated
      public var paymentRef: CLVModels.Payments.Payment?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(id, forKey: "id")
        aCoder.encode(name, forKey: "name")
        aCoder.encode(amount, forKey: "amount")
        aCoder.encode(paymentRef, forKey: "paymentRef")
      }
      
      required public init(coder aDecoder: NSCoder) {
        id = aDecoder.decodeObject(forKey: "id") as? String
        name = aDecoder.decodeObject(forKey: "name") as? String
        amount = aDecoder.decodeObject(forKey: "amount") as? Int
        paymentRef = aDecoder.decodeObject(forKey: "paymentRef") as? CLVModels.Payments.Payment
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        id <- map["id"]
        name <- map["name"]
        amount <- map["amount"]
        paymentRef <- map["paymentRef"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments17TaxableAmountRate)public class TaxableAmountRate: NSObject, NSCoding, Mappable {
      public var id: String?
      public var name: String?
      public var taxableAmount: Int?
      public var rate: Int?
      public var isVat: Bool?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(id, forKey: "id")
        aCoder.encode(name, forKey: "name")
        aCoder.encode(taxableAmount, forKey: "taxableAmount")
        aCoder.encode(rate, forKey: "rate")
        aCoder.encode(isVat, forKey: "isVat")
      }
      
      required public init(coder aDecoder: NSCoder) {
        id = aDecoder.decodeObject(forKey: "id") as? String
        name = aDecoder.decodeObject(forKey: "name") as? String
        taxableAmount = aDecoder.decodeObject(forKey: "taxableAmount") as? Int
        rate = aDecoder.decodeObject(forKey: "rate") as? Int
        isVat = aDecoder.decodeObject(forKey: "isVat") as? Bool
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        id <- map["id"]
        name <- map["name"]
        taxableAmount <- map["taxableAmount"]
        rate <- map["rate"]
        isVat <- map["isVat"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments11Transaction)public class Transaction: NSObject, NSCoding, Mappable {
      /// The time when the transaction was recorded on the server
      public var createdTime: Date?
      /// The time when the transaction was recorded on the client
      public var clientCreatedTime: Date?
      public var payment: CLVModels.Payments.Payment?
      public var refund: CLVModels.Payments.Refund?
      public var credit: CLVModels.Payments.Credit?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(createdTime, forKey: "createdTime")
        aCoder.encode(clientCreatedTime, forKey: "clientCreatedTime")
        aCoder.encode(payment, forKey: "payment")
        aCoder.encode(refund, forKey: "refund")
        aCoder.encode(credit, forKey: "credit")
      }
      
      required public init(coder aDecoder: NSCoder) {
        createdTime = aDecoder.decodeObject(forKey: "createdTime") as? Date
        clientCreatedTime = aDecoder.decodeObject(forKey: "clientCreatedTime") as? Date
        payment = aDecoder.decodeObject(forKey: "payment") as? CLVModels.Payments.Payment
        refund = aDecoder.decodeObject(forKey: "refund") as? CLVModels.Payments.Refund
        credit = aDecoder.decodeObject(forKey: "credit") as? CLVModels.Payments.Credit
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        createdTime <- (map["createdTime"], CLVDateTransform())
        clientCreatedTime <- (map["clientCreatedTime"], CLVDateTransform())
        payment <- map["payment"]
        refund <- map["refund"]
        credit <- map["credit"]
      }
    }
    
    
    
    public enum TxType: String {
      case AUTH
      case PREAUTH
      case PREAUTHCAPTURE
      case ADJUST
      case VOID
      case VOIDRETURN
      case RETURN
      case REFUND
      case NAKEDREFUND
      case GETBALANCE
      case BATCHCLOSE
      case ACTIVATE
      case BALANCE_LOCK
      case LOAD
      case CASHOUT
      case CASHOUT_ACTIVE_STATUS
      case REDEMPTION
      case REDEMPTION_UNLOCK
      case RELOAD
    }
    

    public enum TipMode: String {
        case TIP_PROVIDED
        case ON_SCREEN_BEFORE_PAYMENT
        case ON_SCREEN_AFTER_PAYMENT
        case ON_PAPER
        case NO_TIP
    }
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments19TransactionSettings)public class TransactionSettings: NSObject, NSCoding, Mappable {
        
        public var cardEntryMethods: Int?
        
        public var disableCashBack: Bool?
        
        public var cloverShouldHandleReceipts: Bool?
        
        public var forcePinEntryOnSwipe: Bool?
        
        public var disableRestartTransactionOnFailure: Bool?
        
        public var allowOfflinePayment: Bool?
        
        public var approveOfflinePaymentWithoutPrompt: Bool?
        
        public var signatureThreshold: Int?
        
        public var signatureEntryLocation: CLVModels.Payments.DataEntryLocation? = nil
        
        public var tipMode: CLVModels.Payments.TipMode? = nil
        
        public var tippableAmount: Int?
        
        public var disableReceiptSelection: Bool?
        
        public var disableDuplicateCheck: Bool?
        
        public var autoAcceptPaymentConfirmations: Bool?
        
        public var autoAcceptSignature: Bool?
        
        public var forceOfflinePayment: Bool?
        
        public func encode(with aCoder: NSCoder) {
            aCoder.encode(cardEntryMethods, forKey: "cardEntryMethods")
            aCoder.encode(disableCashBack, forKey: "disableCashBack")
            aCoder.encode(cloverShouldHandleReceipts, forKey: "cloverShouldHandleReceipts")
            aCoder.encode(forcePinEntryOnSwipe, forKey: "forcePinEntryOnSwipe")
            aCoder.encode(disableRestartTransactionOnFailure, forKey: "disableRestartTransactionOnFailure")
            aCoder.encode(allowOfflinePayment, forKey: "allowOfflinePayment")
            aCoder.encode(approveOfflinePaymentWithoutPrompt, forKey: "approveOfflinePaymentWithoutPrompt")
            aCoder.encode(signatureThreshold, forKey: "signatureThreshold")
            aCoder.encode(signatureEntryLocation?.rawValue, forKey: "signatureEntryLocation")
            aCoder.encode(tipMode?.rawValue, forKey: "tipMode")
            aCoder.encode(tippableAmount, forKey: "tippableAmount")
            aCoder.encode(disableReceiptSelection, forKey: "disableReceiptSelection")
            aCoder.encode(disableDuplicateCheck, forKey: "disableDuplicateCheck")
            aCoder.encode(autoAcceptPaymentConfirmations, forKey: "autoAcceptPaymentConfirmations")
            aCoder.encode(autoAcceptSignature, forKey: "autoAcceptSignature")
            aCoder.encode(forceOfflinePayment, forKey: "forceOfflinePayment")
        }
        
        required public init(coder aDecoder: NSCoder) {
            cardEntryMethods = aDecoder.decodeObject(forKey: "cardEntryMethods") as? Int
            disableCashBack = aDecoder.decodeObject(forKey: "disableCashBack") as? Bool
            cloverShouldHandleReceipts = aDecoder.decodeObject(forKey: "cloverShouldHandleReceipts") as? Bool
            forcePinEntryOnSwipe = aDecoder.decodeObject(forKey: "forcePinEntryOnSwipe") as? Bool
            disableRestartTransactionOnFailure = aDecoder.decodeObject(forKey: "disableRestartTransactionOnFailure") as? Bool
            allowOfflinePayment = aDecoder.decodeObject(forKey: "allowOfflinePayment") as? Bool
            approveOfflinePaymentWithoutPrompt = aDecoder.decodeObject(forKey: "approveOfflinePaymentWithoutPrompt") as? Bool
            signatureThreshold = aDecoder.decodeObject(forKey: "signatureThreshold") as? Int
            if let signatureEntryLocationString = aDecoder.decodeObject(forKey: "signatureEntryLocation") as? String {
                signatureEntryLocation = CLVModels.Payments.DataEntryLocation(rawValue: signatureEntryLocationString)
            }
            if let tipModeString = aDecoder.decodeObject(forKey: "tipMode") as? String {
                tipMode = CLVModels.Payments.TipMode(rawValue: tipModeString)
            }
            tippableAmount = aDecoder.decodeObject(forKey: "tippableAmount") as? Int
            disableReceiptSelection = aDecoder.decodeObject(forKey: "disableReceiptSelection") as? Bool
            disableDuplicateCheck = aDecoder.decodeObject(forKey: "disableDuplicateCheck") as? Bool
            autoAcceptPaymentConfirmations = aDecoder.decodeObject(forKey: "autoAcceptPaymentConfirmations") as? Bool
            autoAcceptSignature = aDecoder.decodeObject(forKey: "autoAcceptSignature") as? Bool
            forceOfflinePayment = aDecoder.decodeObject(forKey: "forceOfflinePayment") as? Bool
        }
        
        override public init() {}
        
        // Mappable
        required public init?(map:Map) {}
        
        public func mapping(map:Map) {
            cardEntryMethods <- map["cardEntryMethods"]
            disableCashBack <- map["disableCashBack"]
            cloverShouldHandleReceipts <- map["cloverShouldHandleReceipts"]
            forcePinEntryOnSwipe <- map["forcePinEntryOnSwipe"]
            disableRestartTransactionOnFailure <- map["disableRestartTransactionOnFailure"]
            allowOfflinePayment <- map["allowOfflinePayment"]
            approveOfflinePaymentWithoutPrompt <- map["approveOfflinePaymentWithoutPrompt"]
            signatureThreshold <- map["signatureThreshold"]
            signatureEntryLocation <- map["signatureEntryLocation"]
            tipMode <- map["tipMode"]
            tippableAmount <- map["tippableAmount"]
            disableReceiptSelection <- map["disableReceiptSelection"]
            disableDuplicateCheck <- map["disableDuplicateCheck"]
            autoAcceptPaymentConfirmations <- map["autoAcceptPaymentConfirmations"]
            autoAcceptSignature <- map["autoAcceptSignature"]
            forceOfflinePayment <- map["forceOfflinePayment"]
        }
    }
    
    
    public enum Type_: String {
      case TAB
      case AUTH
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments11VaultedCard)public class VaultedCard: NSObject, NSCoding, Mappable {
      public var first6: String?
      public var last4: String?
      public var cardholderName: String?
      public var expirationDate: String?
      public var token: String?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(first6, forKey: "first6")
        aCoder.encode(last4, forKey: "last4")
        aCoder.encode(cardholderName, forKey: "cardholderName")
        aCoder.encode(expirationDate, forKey: "expirationDate")
        aCoder.encode(token, forKey: "token")
      }
      
      required public init(coder aDecoder: NSCoder) {
        first6 = aDecoder.decodeObject(forKey: "first6") as? String
        last4 = aDecoder.decodeObject(forKey: "last4") as? String
        cardholderName = aDecoder.decodeObject(forKey: "cardholderName") as? String
        expirationDate = aDecoder.decodeObject(forKey: "expirationDate") as? String
        token = aDecoder.decodeObject(forKey: "token") as? String
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        first6 <- map["first6"]
        last4 <- map["last4"]
        cardholderName <- map["cardholderName"]
        expirationDate <- map["expirationDate"]
        token <- map["token"]
      }
    }
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments8CardData)public class CardData:NSObject, NSCoding, Mappable {
        public var track1:String?
        public var track2:String?
        public var track3:String?
        public var encrypted:Bool?
        public var maskedTrack1:String?
        public var maskedTrack2:String?
        public var maskedTrack3:String?
        public var pan:String?
        public var cardholderName:String?
        public var firstName:String?
        public var lastName:String?
        public var exp:String?
        public var last4:String?
        public var first6:String?
        
        public func encode(with aCoder: NSCoder) {
            aCoder.encode(track1, forKey: "track1")
            aCoder.encode(track2, forKey: "track2")
            aCoder.encode(track3, forKey: "track3")
            aCoder.encode(encrypted, forKey: "encrypted")
            aCoder.encode(maskedTrack1, forKey: "maskedTrack1")
            aCoder.encode(maskedTrack2, forKey: "maskedTrack2")
            aCoder.encode(maskedTrack3, forKey: "maskedTrack3")
            aCoder.encode(pan, forKey: "pan")
            aCoder.encode(cardholderName, forKey: "cardholderName")
            aCoder.encode(firstName, forKey: "firstName")
            aCoder.encode(lastName, forKey: "lastName")
            aCoder.encode(exp, forKey: "exp")
            aCoder.encode(last4, forKey: "last4")
            aCoder.encode(first6, forKey: "first6")
            
        }
        
        required public init(coder aDecoder: NSCoder) {
            track1 = aDecoder.decodeObject(forKey: "track1") as? String
            track2 = aDecoder.decodeObject(forKey: "track2") as? String
            track3 = aDecoder.decodeObject(forKey: "track3") as? String
            encrypted = aDecoder.decodeObject(forKey: "encrypted") as? Bool
            maskedTrack1 = aDecoder.decodeObject(forKey: "maskedTrack1") as? String
            maskedTrack2 = aDecoder.decodeObject(forKey: "maskedTrack2") as? String
            maskedTrack3 = aDecoder.decodeObject(forKey: "maskedTrack3") as? String
            pan = aDecoder.decodeObject(forKey: "pan") as? String
            cardholderName = aDecoder.decodeObject(forKey: "cardholderName") as? String
            firstName = aDecoder.decodeObject(forKey: "firstName") as? String
            lastName = aDecoder.decodeObject(forKey: "lastName") as? String
            exp = aDecoder.decodeObject(forKey: "exp") as? String
            last4 = aDecoder.decodeObject(forKey: "last4") as? String
            first6 = aDecoder.decodeObject(forKey: "first6") as? String
        }
        
        override public init() {}
        
        required public init?(map:Map) {}
        
        public func mapping(map:Map) {
            track1 <- map["track1"]
            track2 <- map["track2"]
            track3 <- map["track3"]
            encrypted <- map["encrypted"]
            maskedTrack1 <- map["maskedTrack1"]
            maskedTrack2 <- map["maskedTrack2"]
            maskedTrack3 <- map["maskedTrack3"]
            pan <- map["pan"]
            cardholderName <- map["cardholderName"]
            firstName <- map["firstName"]
            lastName <- map["lastName"]
            exp <- map["exp"]
            last4 <- map["last4"]
            first6 <- map["first6"]
        }
    }
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments19PendingPaymentEntry)public class PendingPaymentEntry : NSObject, NSCoding, Mappable {
        public var paymentId:String?
        public var amount:Int?
        
        
        public func encode(with aCoder: NSCoder) {
            aCoder.encode(paymentId, forKey: "paymentId")
            aCoder.encode(amount, forKey: "amount")
        }
        
        required public init(coder aDecoder: NSCoder) {
            paymentId = aDecoder.decodeObject(forKey: "paymentId") as? String
            amount = aDecoder.decodeObject(forKey: "amount") as? Int
        }
        
        override public init() {}
        
        required public init?(map:Map) {}
        
        public func mapping(map:Map) {
            paymentId <- map["paymentId"]
            amount <- map["amount"]
        }
    }
  }
}
