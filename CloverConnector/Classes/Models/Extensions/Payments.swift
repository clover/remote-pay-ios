
/**
 * Autogenerated by Avro
 *
 * DO NOT EDIT DIRECTLY
 */

import ObjectMapper

extension CLVModels {
  public class Payments {
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments13Authorization)public class Authorization: NSObject, NSCoding, Mappable {
      /// Unique identifier
      public var id: String?
      /// Payment that the auth was opened with
      public var payment: CLVModels.Payments.Payment?
      /// Name of tab
      public var tabName: String?
      /// Amount authorized
      public var amount: Int?
      /// Type of credit card used for authorization
      public var cardType: CLVModels.Payments.CardType? = nil
      /// Last 4 digits of credit card used for authorization
      public var last4: String?
      /// Authorization code
      public var authcode: String?
      public var type_: CLVModels.Payments.Type_? = nil
      public var note: String?
      /// Payment that the auth was closed with
      public var closingPayment: CLVModels.Payments.Payment?
      /// Time authorization was recorded on server
      public var createdTime: Date?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(id, forKey: "id")
        aCoder.encode(payment, forKey: "payment")
        aCoder.encode(tabName, forKey: "tabName")
        aCoder.encode(amount, forKey: "amount")
        aCoder.encode(cardType?.rawValue, forKey: "cardType")
        aCoder.encode(last4, forKey: "last4")
        aCoder.encode(authcode, forKey: "authcode")
        aCoder.encode(type_?.rawValue, forKey: "type_")
        aCoder.encode(note, forKey: "note")
        aCoder.encode(closingPayment, forKey: "closingPayment")
        aCoder.encode(createdTime, forKey: "createdTime")
      }
      
      required public init(coder aDecoder: NSCoder) {
        id = aDecoder.decodeObject(forKey: "id") as? String
        payment = aDecoder.decodeObject(forKey: "payment") as? CLVModels.Payments.Payment
        tabName = aDecoder.decodeObject(forKey: "tabName") as? String
        amount = aDecoder.decodeObject(forKey: "amount") as? Int
        if let cardTypeString = aDecoder.decodeObject(forKey: "cardType") as? String {
            cardType = CLVModels.Payments.CardType(rawValue: cardTypeString)
        }
        last4 = aDecoder.decodeObject(forKey: "last4") as? String
        authcode = aDecoder.decodeObject(forKey: "authcode") as? String
        if let typeString = aDecoder.decodeObject(forKey: "type_") as? String {
            type_ = CLVModels.Payments.Type_(rawValue: typeString)
        }
        note = aDecoder.decodeObject(forKey: "note") as? String
        closingPayment = aDecoder.decodeObject(forKey: "closingPayment") as? CLVModels.Payments.Payment
        createdTime = aDecoder.decodeObject(forKey: "createdTime") as? Date
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        id <- map["id"]
        payment <- map["payment"]
        tabName <- map["tabName"]
        amount <- map["amount"]
        cardType <- map["cardType"]
        last4 <- map["last4"]
        authcode <- map["authcode"]
        type_ <- map["type"]
        note <- map["note"]
        closingPayment <- map["closingPayment"]
        createdTime <- (map["createdTime"], CLVDateTransform())
      }
    }
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments24IncrementalAuthorization)public class IncrementalAuthorization: NSObject, NSCoding, Mappable {
        /// Unique identifier
        public var id: String?
        /// Amount of the incremental authorization
        public var amount: Int?
        public var cardTransaction: CLVModels.Payments.CardTransaction?
        /// Result of the incremental auth
        public var result: Result?
        /// Created time on the server
        public var createdTime: Date?
        /// The employee who processed the incremental Auth
        public var employee: CLVModels.Employees.Employee?
        
        //NSCoding
        public func encode(with coder: NSCoder) {
            coder.encode(id, forKey: "id")
            coder.encode(amount, forKey: "amount")
            coder.encode(cardTransaction, forKey: "cardTransaction")
            coder.encode(result, forKey: "result")
            coder.encode(createdTime, forKey: "createdTime")
            coder.encode(employee, forKey: "employee")
        }
        
        required public init(coder decoder: NSCoder) {
            id = decoder.decodeObject(forKey: "id") as? String
            amount = decoder.decodeObject(forKey: "amount") as? Int
            cardTransaction = decoder.decodeObject(forKey: "cardTransaction") as? CLVModels.Payments.CardTransaction
            result = decoder.decodeObject(forKey: "result") as? Result
            createdTime = decoder.decodeObject(forKey: "createdTime") as? Date
            employee = decoder.decodeObject(forKey: "employee") as? CLVModels.Employees.Employee
        }
        
        //Mappable
        public required init?(map: Map) { }
        
        public func mapping(map: Map) {
            id <- map["id"]
            amount <- map["amount"]
            cardTransaction <- map["cardTransaction"]
            result <- map["result"]
            createdTime <- (map["createdTime"], CLVDateTransform())
            employee <- map["employee"]
        }
    }
    
    
    public enum AVSResult: String {
      case SUCCESS
      case ZIP_CODE_MATCH
      case ZIP_CODE_MATCH_ADDRESS_NOT_CHECKED
      case ADDRESS_MATCH
      case ADDRESS_MATCH_ZIP_NOT_CHECKED
      case NEITHER_MATCH
      case SERVICE_FAILURE
      case SERVICE_UNAVAILABLE
      case NOT_CHECKED
      case ZIP_CODE_NOT_MATCHED_ADDRESS_NOT_CHECKED
      case ADDRESS_NOT_MATCHED_ZIP_CODE_NOT_CHECKED
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments5Batch)public class Batch: NSObject, NSCoding, Mappable {
      public var id: String?
      public var merchantId: Int?
      public var firstGatewayTxId: Int?
      public var lastGatewayTxId: Int?
      /// The id of employee who executed batch
      public var accountId: Int?
      /// The number of transactions being batched
      public var txCount: Int?
      /// Total amount closed
      public var totalBatchAmount: Int?
      /// List of devices in batch
      public var devices: String?
      public var state: CLVModels.Payments.BatchState? = nil
      public var batchType: CLVModels.Payments.BatchType? = nil
      /// Created time of batch
      public var createdTime: Date?
      /// Modified time of batch
      public var modifiedTime: Date?
      /// Details split based on card / employees
      public var batchDetails: CLVModels.Payments.BatchDetail?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(id, forKey: "id")
        aCoder.encode(merchantId, forKey: "merchantId")
        aCoder.encode(firstGatewayTxId, forKey: "firstGatewayTxId")
        aCoder.encode(lastGatewayTxId, forKey: "lastGatewayTxId")
        aCoder.encode(accountId, forKey: "accountId")
        aCoder.encode(txCount, forKey: "txCount")
        aCoder.encode(totalBatchAmount, forKey: "totalBatchAmount")
        aCoder.encode(devices, forKey: "devices")
        aCoder.encode(state?.rawValue, forKey: "state")
        aCoder.encode(batchType?.rawValue, forKey: "batchType")
        aCoder.encode(createdTime, forKey: "createdTime")
        aCoder.encode(modifiedTime, forKey: "modifiedTime")
        aCoder.encode(batchDetails, forKey: "batchDetails")
      }
      
      required public init(coder aDecoder: NSCoder) {
        id = aDecoder.decodeObject(forKey: "id") as? String
        merchantId = aDecoder.decodeObject(forKey: "merchantId") as? Int
        firstGatewayTxId = aDecoder.decodeObject(forKey: "firstGatewayTxId") as? Int
        lastGatewayTxId = aDecoder.decodeObject(forKey: "lastGatewayTxId") as? Int
        accountId = aDecoder.decodeObject(forKey: "accountId") as? Int
        txCount = aDecoder.decodeObject(forKey: "txCount") as? Int
        totalBatchAmount = aDecoder.decodeObject(forKey: "totalBatchAmount") as? Int
        devices = aDecoder.decodeObject(forKey: "devices") as? String
        if let stateString = aDecoder.decodeObject(forKey: "state") as? String {
            state = CLVModels.Payments.BatchState(rawValue: stateString)
        }
        if let batchTypeString = aDecoder.decodeObject(forKey: "batchType") as? String {
            batchType = CLVModels.Payments.BatchType(rawValue: batchTypeString)
        }
        createdTime = aDecoder.decodeObject(forKey: "createdTime") as? Date
        modifiedTime = aDecoder.decodeObject(forKey: "modifiedTime") as? Date
        batchDetails = aDecoder.decodeObject(forKey: "batchDetails") as? CLVModels.Payments.BatchDetail
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        id <- map["id"]
        merchantId <- map["merchantId"]
        firstGatewayTxId <- map["firstGatewayTxId"]
        lastGatewayTxId <- map["lastGatewayTxId"]
        accountId <- map["accountId"]
        txCount <- map["txCount"]
        totalBatchAmount <- map["totalBatchAmount"]
        devices <- map["devices"]
        state <- map["state"]
        batchType <- map["batchType"]
        createdTime <- (map["createdTime"], CLVDateTransform())
        modifiedTime <- (map["modifiedTime"], CLVDateTransform())
        batchDetails <- map["batchDetails"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments14BatchCardTotal)public class BatchCardTotal: NSObject, NSCoding, Mappable {
      public var cardType: CLVModels.Payments.CardType? = nil
      /// Total count of types
      public var count: Int?
      /// Total amount for type
      public var total: Int?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(cardType?.rawValue, forKey: "cardType")
        aCoder.encode(count, forKey: "count")
        aCoder.encode(total, forKey: "total")
      }
      
      required public init(coder aDecoder: NSCoder) {
        if let cardTypeString = aDecoder.decodeObject(forKey: "cardType") as? String {
            cardType = CLVModels.Payments.CardType(rawValue: cardTypeString)
        }
        count = aDecoder.decodeObject(forKey: "count") as? Int
        total = aDecoder.decodeObject(forKey: "total") as? Int
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        cardType <- map["cardType"]
        count <- map["count"]
        total <- map["total"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments11BatchDetail)public class BatchDetail: NSObject, NSCoding, Mappable {
      public var batchTotals: CLVModels.Payments.BatchTotalStats?
      public var serverTotals: [CLVModels.Payments.ServerTotalStats]?
      public var cardTotals: [CLVModels.Payments.BatchCardTotal]?
      /// Number of public tips.
      public var openTips: Int?
      /// Number of public tabs.
      public var openTabs: Int?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(batchTotals, forKey: "batchTotals")
        aCoder.encode(serverTotals, forKey: "serverTotals")
        aCoder.encode(cardTotals, forKey: "cardTotals")
        aCoder.encode(openTips, forKey: "openTips")
        aCoder.encode(openTabs, forKey: "openTabs")
      }
      
      required public init(coder aDecoder: NSCoder) {
        batchTotals = aDecoder.decodeObject(forKey: "batchTotals") as? CLVModels.Payments.BatchTotalStats
        serverTotals = aDecoder.decodeObject(forKey: "serverTotals") as? [CLVModels.Payments.ServerTotalStats]
        cardTotals = aDecoder.decodeObject(forKey: "cardTotals") as? [CLVModels.Payments.BatchCardTotal]
        openTips = aDecoder.decodeObject(forKey: "openTips") as? Int
        openTabs = aDecoder.decodeObject(forKey: "openTabs") as? Int
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        batchTotals <- map["batchTotals"]
        serverTotals <- map["serverTotals.elements"]
        cardTotals <- map["cardTotals.elements"]
        openTips <- map["openTips"]
        openTabs <- map["openTabs"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments12BatchRequest)public class BatchRequest: NSObject, NSCoding, Mappable {
      public var devices: [String]?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(devices, forKey: "devices")
      }
      
      required public init(coder aDecoder: NSCoder) {
        devices = aDecoder.decodeObject(forKey: "devices") as? [String]
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        devices <- map["devices"]
      }
    }
    
    
    
    public enum BatchState: String {
      case OPEN
      case QUEUED_FOR_PROCESSING
      case PROCESSING
      case CLOSED
      case FAILED
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments15BatchTotalStats)public class BatchTotalStats: NSObject, NSCoding, Mappable {
      public var sales: CLVModels.Payments.BatchTotalType?
      public var refunds: CLVModels.Payments.BatchTotalType?
      public var net: CLVModels.Payments.BatchTotalType?
      public var giftCardLoads: CLVModels.Payments.BatchTotalType?
      public var giftCardCashOuts: CLVModels.Payments.BatchTotalType?
      public var tax: CLVModels.Payments.BatchTotalType?
      public var tips: CLVModels.Payments.BatchTotalType?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(sales, forKey: "sales")
        aCoder.encode(refunds, forKey: "refunds")
        aCoder.encode(net, forKey: "net")
        aCoder.encode(giftCardLoads, forKey: "giftCardLoads")
        aCoder.encode(giftCardCashOuts, forKey: "giftCardCashOuts")
        aCoder.encode(tax, forKey: "tax")
        aCoder.encode(tips, forKey: "tips")
      }
      
      required public init(coder aDecoder: NSCoder) {
        sales = aDecoder.decodeObject(forKey: "sales") as? CLVModels.Payments.BatchTotalType
        refunds = aDecoder.decodeObject(forKey: "refunds") as? CLVModels.Payments.BatchTotalType
        net = aDecoder.decodeObject(forKey: "net") as? CLVModels.Payments.BatchTotalType
        giftCardLoads = aDecoder.decodeObject(forKey: "giftCardLoads") as? CLVModels.Payments.BatchTotalType
        giftCardCashOuts = aDecoder.decodeObject(forKey: "giftCardCashOuts") as? CLVModels.Payments.BatchTotalType
        tax = aDecoder.decodeObject(forKey: "tax") as? CLVModels.Payments.BatchTotalType
        tips = aDecoder.decodeObject(forKey: "tips") as? CLVModels.Payments.BatchTotalType
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        sales <- map["sales"]
        refunds <- map["refunds"]
        net <- map["net"]
        giftCardLoads <- map["giftCardLoads"]
        giftCardCashOuts <- map["giftCardCashOuts"]
        tax <- map["tax"]
        tips <- map["tips"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments14BatchTotalType)public class BatchTotalType: NSObject, NSCoding, Mappable {
      /// Total count of types
      public var count: Int?
      /// Total amount for type
      public var total: Int?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(count, forKey: "count")
        aCoder.encode(total, forKey: "total")
      }
      
      required public init(coder aDecoder: NSCoder) {
        count = aDecoder.decodeObject(forKey: "count") as? Int
        total = aDecoder.decodeObject(forKey: "total") as? Int
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        count <- map["count"]
        total <- map["total"]
      }
    }
    
    
    
    public enum BatchType: String {
      case MANUAL_CLOSE
      case AUTO_CLOSE
    }
    
    
    
    public enum CardEntryType: String {
      case SWIPED
      case KEYED
      case VOICE
      case VAULTED
      case OFFLINE_SWIPED
      case OFFLINE_KEYED
      case EMV_CONTACT
      case EMV_CONTACTLESS
      case MSD_CONTACTLESS
      case PINPAD_MANUAL_ENTRY
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments15CardTransaction)public class CardTransaction: NSObject, NSCoding, Mappable {
      /// The payment with which the card transaction is associated
      public var paymentRef: CLVModels.Payments.Payment?
      /// The credit with which the card transaction is associated
      public var creditRef: CLVModels.Payments.Credit?
      public var cardType: CLVModels.Payments.CardType? = nil
      public var entryType: CLVModels.Payments.CardEntryType? = nil
      /// The first four digits of the card number
      public var first6: String?
      /// The last four digits of the card number
      public var last4: String?
      public var type_: CLVModels.Payments.CardTransactionType? = nil
      /// Authorization code (if successful)
      public var authCode: String?
      public var referenceId: String?
      public var transactionNo: String?
      public var state: CLVModels.Payments.CardTransactionState? = nil
      /// Extra info to be stored as part of gateway/card transaction
      public var extra: [String:String]?
      public var begBalance: Int?
      public var endBalance: Int?
      public var avsResult: CLVModels.Payments.AVSResult? = nil
      public var cardholderName: String?
      public var token: String?
      public var vaultedCard: VaultedCard?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(paymentRef, forKey: "paymentRef")
        aCoder.encode(creditRef, forKey: "creditRef")
        aCoder.encode(cardType?.rawValue, forKey: "cardType")
        aCoder.encode(entryType?.rawValue, forKey: "entryType")
        aCoder.encode(first6, forKey: "first6")
        aCoder.encode(last4, forKey: "last4")
        aCoder.encode(type_?.rawValue, forKey: "type_")
        aCoder.encode(authCode, forKey: "authCode")
        aCoder.encode(referenceId, forKey: "referenceId")
        aCoder.encode(transactionNo, forKey: "transactionNo")
        aCoder.encode(state?.rawValue, forKey: "state")
        aCoder.encode(extra, forKey: "extra")
        aCoder.encode(begBalance, forKey: "begBalance")
        aCoder.encode(endBalance, forKey: "endBalance")
        aCoder.encode(avsResult?.rawValue, forKey: "avsResult")
        aCoder.encode(cardholderName, forKey: "cardholderName")
        aCoder.encode(token, forKey: "token")
        aCoder.encode(token, forKey: "vaultedCard")
      }
      
      required public init(coder aDecoder: NSCoder) {
        paymentRef = aDecoder.decodeObject(forKey: "paymentRef") as? CLVModels.Payments.Payment
        creditRef = aDecoder.decodeObject(forKey: "creditRef") as? CLVModels.Payments.Credit
        if let cardTypeString = aDecoder.decodeObject(forKey: "cardType") as? String {
            cardType = CLVModels.Payments.CardType(rawValue: cardTypeString)
        }
        if let entryTypeString = aDecoder.decodeObject(forKey: "entryType") as? String {
            entryType = CLVModels.Payments.CardEntryType(rawValue: entryTypeString)
        }
        first6 = aDecoder.decodeObject(forKey: "first6") as? String
        last4 = aDecoder.decodeObject(forKey: "last4") as? String
        if let typeString = aDecoder.decodeObject(forKey: "type_") as? String {
            type_ = CLVModels.Payments.CardTransactionType(rawValue: typeString)
        }
        authCode = aDecoder.decodeObject(forKey: "authCode") as? String
        referenceId = aDecoder.decodeObject(forKey: "referenceId") as? String
        transactionNo = aDecoder.decodeObject(forKey: "transactionNo") as? String
        if let stateString = aDecoder.decodeObject(forKey: "state") as? String {
            state = CLVModels.Payments.CardTransactionState(rawValue: stateString)
        }
        extra = aDecoder.decodeObject(forKey: "extra") as? [String:String]
        begBalance = aDecoder.decodeObject(forKey: "begBalance") as? Int
        endBalance = aDecoder.decodeObject(forKey: "endBalance") as? Int
        if let avsResultString = aDecoder.decodeObject(forKey: "avsResult") as? String {
            avsResult = CLVModels.Payments.AVSResult(rawValue: avsResultString)
        }
        cardholderName = aDecoder.decodeObject(forKey: "cardholderName") as? String
        token = aDecoder.decodeObject(forKey: "token") as? String
        vaultedCard = aDecoder.decodeObject(forKey: "vaultedCard") as? CLVModels.Payments.VaultedCard
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        paymentRef <- map["paymentRef"]
        creditRef <- map["creditRef"]
        cardType <- map["cardType"]
        entryType <- map["entryType"]
        first6 <- map["first6"]
        last4 <- map["last4"]
        type_ <- map["type"]
        authCode <- map["authCode"]
        referenceId <- map["referenceId"]
        transactionNo <- map["transactionNo"]
        state <- map["state"]
        extra <- map["extra"]
        begBalance <- map["begBalance"]
        endBalance <- map["endBalance"]
        avsResult <- map["avsResult"]
        cardholderName <- map["cardholderName"]
        token <- map["token"]
        vaultedCard <- map["vaultedCard"]
      }
    }
    
    
    
    public enum CardTransactionState: String {
      case PENDING
      case CLOSED
    }
    
    
    
    public enum CardTransactionType: String {
      case AUTH
      case PREAUTH
      case PREAUTHCAPTURE
      case ADJUST
      case VOID
      case VOIDRETURN
      case RETURN
      case REFUND
      case NAKEDREFUND
      case GETBALANCE
      case BATCHCLOSE
      case ACTIVATE
      case BALANCE_LOCK
      case LOAD
      case CASHOUT
      case CASHOUT_ACTIVE_STATUS
      case REDEMPTION
      case REDEMPTION_UNLOCK
      case RELOAD
    }
    
    
    
    public enum CardType: String {
      case VISA
      case MC
      case AMEX
      case DISCOVER
      case DINERS_CLUB
      case JCB
      case MAESTRO
      case SOLO
      case LASER
      case CHINA_UNION_PAY
      case CARTE_BLANCHE
      case UNKNOWN
      case GIFT_CARD
      case EBT
      case INTERAC
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments6Credit)public class Credit: NSObject, NSCoding, Mappable {
      /// Unique identifier
      public var id: String?
      /// The order with which the credit is associated
      public var orderRef: CLVModels.Order.Order?
      /// Device which processed this credit
      public var device: CLVModels.Device.Device?
      /// The tender type associated with this payment, e.g. credit card, cash, etc.
      public var tender: CLVModels.Base.Tender?
      /// The employee who processed the payment
      public var employee: CLVModels.Employees.Employee?
      /// Customer who received the credit/refund
      public var customers: CLVModels.Customers.Customer?
      /// Amount paid
      public var amount: Int?
      /// Amount paid in tax
      public var taxAmount: Int?
      public var taxRates: [CLVModels.Payments.TaxableAmountRate]?
      /// Time payment was recorded on server
      public var createdTime: Date?
      public var clientCreatedTime: Date?
      /// Information about the card used for credit/debit card payments
      public var cardTransaction: CLVModels.Payments.CardTransaction?
      public var voided: Bool?
      public var voidReason: String?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(id, forKey: "id")
        aCoder.encode(orderRef, forKey: "orderRef")
        aCoder.encode(device, forKey: "device")
        aCoder.encode(tender, forKey: "tender")
        aCoder.encode(employee, forKey: "employee")
        aCoder.encode(customers, forKey: "customers")
        aCoder.encode(amount, forKey: "amount")
        aCoder.encode(taxAmount, forKey: "taxAmount")
        aCoder.encode(taxRates, forKey: "taxRates")
        aCoder.encode(createdTime, forKey: "createdTime")
        aCoder.encode(clientCreatedTime, forKey: "clientCreatedTime")
        aCoder.encode(cardTransaction, forKey: "cardTransaction")
        aCoder.encode(voided, forKey: "voided")
        aCoder.encode(voidReason, forKey: "voidReason")
      }
      
      required public init(coder aDecoder: NSCoder) {
        id = aDecoder.decodeObject(forKey: "id") as? String
        orderRef = aDecoder.decodeObject(forKey: "orderRef") as? CLVModels.Order.Order
        device = aDecoder.decodeObject(forKey: "device") as? CLVModels.Device.Device
        tender = aDecoder.decodeObject(forKey: "tender") as? CLVModels.Base.Tender
        employee = aDecoder.decodeObject(forKey: "employee") as? CLVModels.Employees.Employee
        customers = aDecoder.decodeObject(forKey: "customers") as? CLVModels.Customers.Customer
        amount = aDecoder.decodeObject(forKey: "amount") as? Int
        taxAmount = aDecoder.decodeObject(forKey: "taxAmount") as? Int
        taxRates = aDecoder.decodeObject(forKey: "taxRates") as? [CLVModels.Payments.TaxableAmountRate]
        createdTime = aDecoder.decodeObject(forKey: "createdTime") as? Date
        clientCreatedTime = aDecoder.decodeObject(forKey: "clientCreatedTime") as? Date
        cardTransaction = aDecoder.decodeObject(forKey: "cardTransaction") as? CLVModels.Payments.CardTransaction
        voided = aDecoder.decodeObject(forKey: "voided") as? Bool
        voidReason = aDecoder.decodeObject(forKey: "voidReason") as? String
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        id <- map["id"]
        orderRef <- map["orderRef"]
        device <- map["device"]
        tender <- map["tender"]
        employee <- map["employee"]
        customers <- map["customers"]
        amount <- map["amount"]
        taxAmount <- map["taxAmount"]
        taxRates <- map["taxRates.elements"]
        createdTime <- (map["createdTime"], CLVDateTransform())
        clientCreatedTime <- (map["clientCreatedTime"], CLVDateTransform())
        cardTransaction <- map["cardTransaction"]
        voided <- map["voided"]
        voidReason <- map["voidReason"]
      }
    }
    
    
    
    public enum Currency: String {
      case USD
      case GBP
      case EUR
    }
    
    
    
    public enum CvmResult: String {
      case NO_CVM_REQUIRED
      case SIGNATURE
      case PIN
      case ONLINE_PIN
      case SIGNATURE_AND_PIN
      case CVM_FAILED
      case DEVICE
    }
    
    
    
    public enum CVVResult: String {
      case SUCCESS
      case FAILURE
      case NOT_PROCESSED
      case NOT_PRESENT
    }
    
    public enum DataEntryLocation: String {
        case ON_SCREEN
        case ON_PAPER
        case NONE
    }
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments10GatewayTxs)public class GatewayTxs: NSObject, NSCoding, Mappable {
      public var merchantGatewayId: Int?
      public var clientId: String?
      public var amount: Int?
      public var adjustAmount: Int?
      public var taxAmount: Int?
      public var tipAmount: Int?
      public var currency: CLVModels.Payments.Currency? = nil
      public var state: CLVModels.Payments.GatewayTxState? = nil
      public var retries: Int?
      public var type_: CLVModels.Payments.GatewayTxType? = nil
      public var entryType: CLVModels.Payments.CardEntryType? = nil
      public var responseCode: String?
      public var responseMessage: String?
      public var first4: String?
      public var last4: String?
      public var cardType: CLVModels.Payments.CardType? = nil
      public var refnum: String?
      public var token: String?
      public var authcode: String?
      public var employeeId: String?
      public var extra: String?
      public var captured: Bool?
      public var swiperSerial: String?
      public var ksnPrefix: String?
      public var createdTime: Date?
      public var modifiedTime: Date?
      public var refundId: Int?
      public var paymentRefundId: Int?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(merchantGatewayId, forKey: "merchantGatewayId")
        aCoder.encode(clientId, forKey: "clientId")
        aCoder.encode(amount, forKey: "amount")
        aCoder.encode(adjustAmount, forKey: "adjustAmount")
        aCoder.encode(taxAmount, forKey: "taxAmount")
        aCoder.encode(tipAmount, forKey: "tipAmount")
        aCoder.encode(currency?.rawValue, forKey: "currency")
        aCoder.encode(state?.rawValue, forKey: "state")
        aCoder.encode(retries, forKey: "retries")
        aCoder.encode(type_?.rawValue, forKey: "type_")
        aCoder.encode(entryType?.rawValue, forKey: "entryType")
        aCoder.encode(responseCode, forKey: "responseCode")
        aCoder.encode(responseMessage, forKey: "responseMessage")
        aCoder.encode(first4, forKey: "first4")
        aCoder.encode(last4, forKey: "last4")
        aCoder.encode(cardType?.rawValue, forKey: "cardType")
        aCoder.encode(refnum, forKey: "refnum")
        aCoder.encode(token, forKey: "token")
        aCoder.encode(authcode, forKey: "authcode")
        aCoder.encode(employeeId, forKey: "employeeId")
        aCoder.encode(extra, forKey: "extra")
        aCoder.encode(captured, forKey: "captured")
        aCoder.encode(swiperSerial, forKey: "swiperSerial")
        aCoder.encode(ksnPrefix, forKey: "ksnPrefix")
        aCoder.encode(createdTime, forKey: "createdTime")
        aCoder.encode(modifiedTime, forKey: "modifiedTime")
        aCoder.encode(refundId, forKey: "refundId")
        aCoder.encode(paymentRefundId, forKey: "paymentRefundId")
      }
      
      required public init(coder aDecoder: NSCoder) {
        merchantGatewayId = aDecoder.decodeObject(forKey: "merchantGatewayId") as? Int
        clientId = aDecoder.decodeObject(forKey: "clientId") as? String
        amount = aDecoder.decodeObject(forKey: "amount") as? Int
        adjustAmount = aDecoder.decodeObject(forKey: "adjustAmount") as? Int
        taxAmount = aDecoder.decodeObject(forKey: "taxAmount") as? Int
        tipAmount = aDecoder.decodeObject(forKey: "tipAmount") as? Int
        if let currencyString = aDecoder.decodeObject(forKey: "currency") as? String {
            currency = CLVModels.Payments.Currency(rawValue: currencyString)
        }
        if let stateString = aDecoder.decodeObject(forKey: "state") as? String {
            state = CLVModels.Payments.GatewayTxState(rawValue: stateString)
        }
        retries = aDecoder.decodeObject(forKey: "retries") as? Int
        if let typeString = aDecoder.decodeObject(forKey: "type_") as? String {
            type_ = CLVModels.Payments.GatewayTxType(rawValue: typeString)
        }
        if let entryTypeString = aDecoder.decodeObject(forKey: "entryType") as? String {
            entryType = CLVModels.Payments.CardEntryType(rawValue: entryTypeString)
        }
        responseCode = aDecoder.decodeObject(forKey: "responseCode") as? String
        responseMessage = aDecoder.decodeObject(forKey: "responseMessage") as? String
        first4 = aDecoder.decodeObject(forKey: "first4") as? String
        last4 = aDecoder.decodeObject(forKey: "last4") as? String
        if let cardTypeString = aDecoder.decodeObject(forKey: "cardType") as? String {
            cardType = CLVModels.Payments.CardType(rawValue: cardTypeString)
        }
        refnum = aDecoder.decodeObject(forKey: "refnum") as? String
        token = aDecoder.decodeObject(forKey: "token") as? String
        authcode = aDecoder.decodeObject(forKey: "authcode") as? String
        employeeId = aDecoder.decodeObject(forKey: "employeeId") as? String
        extra = aDecoder.decodeObject(forKey: "extra") as? String
        captured = aDecoder.decodeObject(forKey: "captured") as? Bool
        swiperSerial = aDecoder.decodeObject(forKey: "swiperSerial") as? String
        ksnPrefix = aDecoder.decodeObject(forKey: "ksnPrefix") as? String
        createdTime = aDecoder.decodeObject(forKey: "createdTime") as? Date
        modifiedTime = aDecoder.decodeObject(forKey: "modifiedTime") as? Date
        refundId = aDecoder.decodeObject(forKey: "refundId") as? Int
        paymentRefundId = aDecoder.decodeObject(forKey: "paymentRefundId") as? Int
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        merchantGatewayId <- map["merchantGatewayId"]
        clientId <- map["clientId"]
        amount <- map["amount"]
        adjustAmount <- map["adjustAmount"]
        taxAmount <- map["taxAmount"]
        tipAmount <- map["tipAmount"]
        currency <- map["currency"]
        state <- map["state"]
        retries <- map["retries"]
        type_ <- map["type"]
        entryType <- map["entryType"]
        responseCode <- map["responseCode"]
        responseMessage <- map["responseMessage"]
        first4 <- map["first4"]
        last4 <- map["last4"]
        cardType <- map["cardType"]
        refnum <- map["refnum"]
        token <- map["token"]
        authcode <- map["authcode"]
        employeeId <- map["employeeId"]
        extra <- map["extra"]
        captured <- map["captured"]
        swiperSerial <- map["swiperSerial"]
        ksnPrefix <- map["ksnPrefix"]
        createdTime <- (map["createdTime"], CLVDateTransform())
        modifiedTime <- (map["modifiedTime"], CLVDateTransform())
        refundId <- map["refundId"]
        paymentRefundId <- map["paymentRefundId"]
      }
    }
    
    
    
    public enum GatewayTxState: String {
      case INITIATED
      case INITIATED_ON_AUTH
      case ACKNOWLEDGED
      case CONNECT_FAILED
      case TIMEOUT
      case FAILED
      case REVERSE_INITIATED
      case REVERSE_INITIATED_ON_AUTH
      case REVERSED
      case REVERSAL_FAILED
    }
    
    
    
    public enum GatewayTxType: String {
      case AUTH
      case PREAUTH
      case PREAUTHCAPTURE
      case ADJUST
      case VOID
      case VOIDRETURN
      case RETURN
      case REFUND
      case NAKEDREFUND
      case GETBALANCE
      case BATCHCLOSE
      case ACTIVATE
      case BALANCE_LOCK
      case LOAD
      case CASHOUT
      case CASHOUT_ACTIVE_STATUS
      case REDEMPTION
      case REDEMPTION_UNLOCK
      case RELOAD
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments8GiftCard)public class GiftCard: NSObject, NSCoding, Mappable {
      /// Track 2 Card Data
      public var track2: String?
      /// Embossed Card Number
      public var cardNumber: String?
      /// Was Account Number Manually Entered
      public var isManuallyEntered: Bool?
      public var deviceSerial: String?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(track2, forKey: "track2")
        aCoder.encode(cardNumber, forKey: "cardNumber")
        aCoder.encode(isManuallyEntered, forKey: "isManuallyEntered")
        aCoder.encode(deviceSerial, forKey: "deviceSerial")
      }
      
      required public init(coder aDecoder: NSCoder) {
        track2 = aDecoder.decodeObject(forKey: "track2") as? String
        cardNumber = aDecoder.decodeObject(forKey: "cardNumber") as? String
        isManuallyEntered = aDecoder.decodeObject(forKey: "isManuallyEntered") as? Bool
        deviceSerial = aDecoder.decodeObject(forKey: "deviceSerial") as? String
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        track2 <- map["track2"]
        cardNumber <- map["cardNumber"]
        isManuallyEntered <- map["isManuallyEntered"]
        deviceSerial <- map["deviceSerial"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments16GiftCardResponse)public class GiftCardResponse: NSObject, NSCoding, Mappable {
      public var txType: CLVModels.Payments.TxType? = nil
      public var state: CLVModels.Payments.GiftCardState? = nil
      /// Transaction Amount
      public var requestAmount: Int?
      public var payment: CLVModels.Payments.Payment?
      public var responseMessage: String?
      public var requestSuccessful: Bool?
      public var accountNumber: String?
      public var giftCardTxUuid: String?
      public var transactionId: String?
      public var referenceUuid: String?
      public var authCode: String?
      public var begBal: Int?
      public var endBal: Int?
      public var holdBal: Int?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(txType?.rawValue, forKey: "txType")
        aCoder.encode(state?.rawValue, forKey: "state")
        aCoder.encode(requestAmount, forKey: "requestAmount")
        aCoder.encode(payment, forKey: "payment")
        aCoder.encode(responseMessage, forKey: "responseMessage")
        aCoder.encode(requestSuccessful, forKey: "requestSuccessful")
        aCoder.encode(accountNumber, forKey: "accountNumber")
        aCoder.encode(giftCardTxUuid, forKey: "giftCardTxUuid")
        aCoder.encode(transactionId, forKey: "transactionId")
        aCoder.encode(referenceUuid, forKey: "referenceUuid")
        aCoder.encode(authCode, forKey: "authCode")
        aCoder.encode(begBal, forKey: "begBal")
        aCoder.encode(endBal, forKey: "endBal")
        aCoder.encode(holdBal, forKey: "holdBal")
      }
      
      required public init(coder aDecoder: NSCoder) {
        if let txTypeString = aDecoder.decodeObject(forKey: "txType") as? String {
            txType = CLVModels.Payments.TxType(rawValue: txTypeString)
        }
        if let stateString = aDecoder.decodeObject(forKey: "state") as? String {
            state = CLVModels.Payments.GiftCardState(rawValue: stateString)
        }
        requestAmount = aDecoder.decodeObject(forKey: "requestAmount") as? Int
        payment = aDecoder.decodeObject(forKey: "payment") as? CLVModels.Payments.Payment
        responseMessage = aDecoder.decodeObject(forKey: "responseMessage") as? String
        requestSuccessful = aDecoder.decodeObject(forKey: "requestSuccessful") as? Bool
        accountNumber = aDecoder.decodeObject(forKey: "accountNumber") as? String
        giftCardTxUuid = aDecoder.decodeObject(forKey: "giftCardTxUuid") as? String
        transactionId = aDecoder.decodeObject(forKey: "transactionId") as? String
        referenceUuid = aDecoder.decodeObject(forKey: "referenceUuid") as? String
        authCode = aDecoder.decodeObject(forKey: "authCode") as? String
        begBal = aDecoder.decodeObject(forKey: "begBal") as? Int
        endBal = aDecoder.decodeObject(forKey: "endBal") as? Int
        holdBal = aDecoder.decodeObject(forKey: "holdBal") as? Int
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        txType <- map["txType"]
        state <- map["state"]
        requestAmount <- map["requestAmount"]
        payment <- map["payment"]
        responseMessage <- map["responseMessage"]
        requestSuccessful <- map["requestSuccessful"]
        accountNumber <- map["accountNumber"]
        giftCardTxUuid <- map["giftCardTxUuid"]
        transactionId <- map["transactionId"]
        referenceUuid <- map["referenceUuid"]
        authCode <- map["authCode"]
        begBal <- map["begBal"]
        endBal <- map["endBal"]
        holdBal <- map["holdBal"]
      }
    }
    
    
    
    public enum GiftCardState: String {
      case INVALID
      case ACTIVATED
      case INACTIVE
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments19GiftCardTransaction)public class GiftCardTransaction: NSObject, NSCoding, Mappable {
      /// Transaction Amount
      public var amount: Int?
      /// Tax Amount
      public var taxAmount: Int?
      public var orderId: String?
      /// Gift Card
      public var card: CLVModels.Payments.GiftCard?
      public var paymentIds: [String]?
      public var ignorePayment: Bool?
      public var serviceChargeAmount: CLVModels.Payments.ServiceChargeAmount?
      public var taxableAmountRates: [CLVModels.Payments.TaxableAmountRate]?
      /// Payments that were made for this line item
      public var lineItems: [CLVModels.Payments.LineItemPayment]?
      public var employeeId: String?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(amount, forKey: "amount")
        aCoder.encode(taxAmount, forKey: "taxAmount")
        aCoder.encode(orderId, forKey: "orderId")
        aCoder.encode(card, forKey: "card")
        aCoder.encode(paymentIds, forKey: "paymentIds")
        aCoder.encode(ignorePayment, forKey: "ignorePayment")
        aCoder.encode(serviceChargeAmount, forKey: "serviceChargeAmount")
        aCoder.encode(taxableAmountRates, forKey: "taxableAmountRates")
        aCoder.encode(lineItems, forKey: "lineItems")
        aCoder.encode(employeeId, forKey: "employeeId")
      }
      
      required public init(coder aDecoder: NSCoder) {
        amount = aDecoder.decodeObject(forKey: "amount") as? Int
        taxAmount = aDecoder.decodeObject(forKey: "taxAmount") as? Int
        orderId = aDecoder.decodeObject(forKey: "orderId") as? String
        card = aDecoder.decodeObject(forKey: "card") as? CLVModels.Payments.GiftCard
        paymentIds = aDecoder.decodeObject(forKey: "paymentIds") as? [String]
        ignorePayment = aDecoder.decodeObject(forKey: "ignorePayment") as? Bool
        serviceChargeAmount = aDecoder.decodeObject(forKey: "serviceChargeAmount") as? CLVModels.Payments.ServiceChargeAmount
        taxableAmountRates = aDecoder.decodeObject(forKey: "taxableAmountRates") as? [CLVModels.Payments.TaxableAmountRate]
        lineItems = aDecoder.decodeObject(forKey: "lineItems") as? [CLVModels.Payments.LineItemPayment]
        employeeId = aDecoder.decodeObject(forKey: "employeeId") as? String
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        amount <- map["amount"]
        taxAmount <- map["taxAmount"]
        orderId <- map["orderId"]
        card <- map["card"]
        paymentIds <- map["paymentIds"]
        ignorePayment <- map["ignorePayment"]
        serviceChargeAmount <- map["serviceChargeAmount"]
        taxableAmountRates <- map["taxableAmountRates.elements"]
        lineItems <- map["lineItems.elements"]
        employeeId <- map["employeeId"]
      }
    }
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments7DCCInfo)public class DCCInfo: NSObject, NSCoding, Mappable {
        
        /// Inquiry Rate ID (IPG)
        public var inquiryRateId: Int?
        
        /// Flag indicating whether DCC was applied on this txn
        public var dccApplied: Bool?
        
        /// Foreign currency code
        public var foreignCurrencyCode: String?
        
        /// Foreign (transaction) amount
        public var foreignAmount: Int?
        
        /// Exchange Rate
        public var exchangeRate: Double?
        
        /// Margin Rate Percentage
        public var marginRatePercentage: String?
        
        /// Exchange Rate Source Name
        public var exchangeRateSourceName: String?
        
        /// Exchange Rate Source Timestamp
        public var exchangeRateSourceTimeStamp: String?
        
        
        public func encode(with aCoder: NSCoder) {
            aCoder.encode(inquiryRateId, forKey: "inquiryRateId")
            aCoder.encode(dccApplied, forKey: "dccApplied")
            aCoder.encode(foreignCurrencyCode, forKey: "foreignCurrencyCode")
            aCoder.encode(foreignAmount, forKey: "foreignAmount")
            aCoder.encode(exchangeRate, forKey: "exchangeRate")
            aCoder.encode(marginRatePercentage, forKey: "marginRatePercentage")
            aCoder.encode(exchangeRateSourceName, forKey: "exchangeRateSourceName")
            aCoder.encode(exchangeRateSourceTimeStamp, forKey: "exchangeRateSourceTimeStamp")
        }
        
        required public init(coder aDecoder: NSCoder) {
            inquiryRateId = aDecoder.decodeObject(forKey: "inquiryRateId") as? Int
            dccApplied = aDecoder.decodeObject(forKey: "dccApplied") as? Bool
            foreignCurrencyCode = aDecoder.decodeObject(forKey: "foreignCurrencyCode") as? String
            foreignAmount = aDecoder.decodeObject(forKey: "foreignAmount") as? Int
            exchangeRate = aDecoder.decodeObject(forKey: "exchangeRate") as? Double
            marginRatePercentage = aDecoder.decodeObject(forKey: "marginRatePercentage") as? String
            exchangeRateSourceName = aDecoder.decodeObject(forKey: "exchangeRateSourceName") as? String
            exchangeRateSourceTimeStamp = aDecoder.decodeObject(forKey: "exchangeRateSourceTimeStamp") as? String
        }
        
        override public init() {}
        
        // Mappable
        required public init?(map:Map) {}
        
        public func mapping(map:Map) {
            inquiryRateId <- map["inquiryRateId"]
            dccApplied <- map["dccApplied"]
            foreignCurrencyCode <- map["foreignCurrencyCode"]
            foreignAmount <- map["foreignAmount"]
            exchangeRate <- map["exchangeRate"]
            marginRatePercentage <- map["marginRatePercentage"]
            exchangeRateSourceName <- map["exchangeRateSourceName"]
            exchangeRateSourceTimeStamp <- map["exchangeRateSourceTimeStamp"]
        }
    }
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments10GermanInfo)public class GermanInfo: NSObject, NSCoding, Mappable {
        
        public var cardTrack2: String?
        
        public var cardSequenceNumber: String?
        
        public var transactionCaseGermany: String?
        
        public var transactionTypeGermany: String?
        
        public var terminalID: String?
        
        public var traceNumber: String?
        
        public var oldTraceNumber: String?
        
        public var receiptNumber: String?
        
        public var transactionAID: String?
        
        public var transactionMSApp: String?
        
        public var transactionScriptResults: String?
        
        public var receiptType: String?
        
        public var customerTransactionDOLValues: String?
        
        public var merchantTransactionDOLValues: String?
        
        public var merchantJournalDOL: String?
        
        public var merchantJournalDOLValues: String?
        
        public var configMerchantId: String?
        
        public var configProductLabel: String?
        
        public var hostResponseAidParBMP53: String?
        
        public var hostResponsePrintDataBM60: String?
        
        public func encode(with aCoder: NSCoder) {
            aCoder.encode(cardTrack2, forKey: "cardTrack2")
            aCoder.encode(cardSequenceNumber, forKey: "cardSequenceNumber")
            aCoder.encode(transactionCaseGermany, forKey: "transactionCaseGermany")
            aCoder.encode(transactionTypeGermany, forKey: "transactionTypeGermany")
            aCoder.encode(terminalID, forKey: "terminalID")
            aCoder.encode(traceNumber, forKey: "traceNumber")
            aCoder.encode(oldTraceNumber, forKey: "oldTraceNumber")
            aCoder.encode(receiptNumber, forKey: "receiptNumber")
            aCoder.encode(transactionAID, forKey: "transactionAID")
            aCoder.encode(transactionMSApp, forKey: "transactionMSApp")
            aCoder.encode(transactionScriptResults, forKey: "transactionScriptResults")
            aCoder.encode(receiptType, forKey: "receiptType")
            aCoder.encode(customerTransactionDOLValues, forKey: "customerTransactionDOLValues")
            aCoder.encode(merchantTransactionDOLValues, forKey: "merchantTransactionDOLValues")
            aCoder.encode(merchantJournalDOL, forKey: "merchantJournalDOL")
            aCoder.encode(merchantJournalDOLValues, forKey: "merchantJournalDOLValues")
            aCoder.encode(configMerchantId, forKey: "configMerchantId")
            aCoder.encode(configProductLabel, forKey: "configProductLabel")
            aCoder.encode(hostResponseAidParBMP53, forKey: "hostResponseAidParBMP53")
            aCoder.encode(hostResponsePrintDataBM60, forKey: "hostResponsePrintDataBM60")
        }
        
        required public init(coder aDecoder: NSCoder) {
            cardTrack2 = aDecoder.decodeObject(forKey: "cardTrack2") as? String
            cardSequenceNumber = aDecoder.decodeObject(forKey: "cardSequenceNumber") as? String
            transactionCaseGermany = aDecoder.decodeObject(forKey: "transactionCaseGermany") as? String
            transactionTypeGermany = aDecoder.decodeObject(forKey: "transactionTypeGermany") as? String
            terminalID = aDecoder.decodeObject(forKey: "terminalID") as? String
            traceNumber = aDecoder.decodeObject(forKey: "traceNumber") as? String
            oldTraceNumber = aDecoder.decodeObject(forKey: "oldTraceNumber") as? String
            receiptNumber = aDecoder.decodeObject(forKey: "receiptNumber") as? String
            transactionAID = aDecoder.decodeObject(forKey: "transactionAID") as? String
            transactionMSApp = aDecoder.decodeObject(forKey: "transactionMSApp") as? String
            transactionScriptResults = aDecoder.decodeObject(forKey: "transactionScriptResults") as? String
            receiptType = aDecoder.decodeObject(forKey: "receiptType") as? String
            customerTransactionDOLValues = aDecoder.decodeObject(forKey: "customerTransactionDOLValues") as? String
            merchantTransactionDOLValues = aDecoder.decodeObject(forKey: "merchantTransactionDOLValues") as? String
            merchantJournalDOL = aDecoder.decodeObject(forKey: "merchantJournalDOL") as? String
            merchantJournalDOLValues = aDecoder.decodeObject(forKey: "merchantJournalDOLValues") as? String
            configMerchantId = aDecoder.decodeObject(forKey: "configMerchantId") as? String
            configProductLabel = aDecoder.decodeObject(forKey: "configProductLabel") as? String
            hostResponseAidParBMP53 = aDecoder.decodeObject(forKey: "hostResponseAidParBMP53") as? String
            hostResponsePrintDataBM60 = aDecoder.decodeObject(forKey: "hostResponsePrintDataBM60") as? String
        }
        
        override public init() {}
        
        // Mappable
        required public init?(map:Map) {}
        
        public func mapping(map:Map) {
            cardTrack2 <- map["cardTrack2"]
            cardSequenceNumber <- map["cardSequenceNumber"]
            transactionCaseGermany <- map["transactionCaseGermany"]
            transactionTypeGermany <- map["transactionTypeGermany"]
            terminalID <- map["terminalID"]
            traceNumber <- map["traceNumber"]
            oldTraceNumber <- map["oldTraceNumber"]
            receiptNumber <- map["receiptNumber"]
            transactionAID <- map["transactionAID"]
            transactionMSApp <- map["transactionMSApp"]
            transactionScriptResults <- map["transactionScriptResults"]
            receiptType <- map["receiptType"]
            customerTransactionDOLValues <- map["customerTransactionDOLValues"]
            merchantTransactionDOLValues <- map["merchantTransactionDOLValues"]
            merchantJournalDOL <- map["merchantJournalDOL"]
            merchantJournalDOLValues <- map["merchantJournalDOLValues"]
            configMerchantId <- map["configMerchantId"]
            configProductLabel <- map["configProductLabel"]
            hostResponseAidParBMP53 <- map["hostResponseAidParBMP53"]
            hostResponsePrintDataBM60 <- map["hostResponsePrintDataBM60"]
        }
    }
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments15LineItemPayment)public class LineItemPayment: NSObject, NSCoding, Mappable {
      /// Unique identifier; TBD this is confusing because it's used as either line item id or payment id
      public var id: String?
      /// The line item with which the line item payment is associated
      public var lineItemRef: CLVModels.Order.LineItem?
      /// The payment with which the line item payment is associated
      public var paymentRef: CLVModels.Payments.Payment?
      /// Percent of this line item covered by this payment
      public var percentage: Int?
      /// Bin this line item payment was for
      public var binName: String?
      /// Payment has been refunded
      public var refunded: Bool?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(id, forKey: "id")
        aCoder.encode(lineItemRef, forKey: "lineItemRef")
        aCoder.encode(paymentRef, forKey: "paymentRef")
        aCoder.encode(percentage, forKey: "percentage")
        aCoder.encode(binName, forKey: "binName")
        aCoder.encode(refunded, forKey: "refunded")
      }
      
      required public init(coder aDecoder: NSCoder) {
        id = aDecoder.decodeObject(forKey: "id") as? String
        lineItemRef = aDecoder.decodeObject(forKey: "lineItemRef") as? CLVModels.Order.LineItem
        paymentRef = aDecoder.decodeObject(forKey: "paymentRef") as? CLVModels.Payments.Payment
        percentage = aDecoder.decodeObject(forKey: "percentage") as? Int
        binName = aDecoder.decodeObject(forKey: "binName") as? String
        refunded = aDecoder.decodeObject(forKey: "refunded") as? Bool
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        id <- map["id"]
        lineItemRef <- map["lineItemRef"]
        paymentRef <- map["paymentRef"]
        percentage <- map["percentage"]
        binName <- map["binName"]
        refunded <- map["refunded"]
      }
    }
    
    @objc(CloverConnectorModelsExtensionsPaymentsAdditionalCharges) public class AdditionalCharges: NSObject, NSCoding, Mappable {
        public var elements:[AdditionalCharge]?
        public func encode(with aCoder: NSCoder) {
            aCoder.encode(elements, forKey: "elements")
        }
        public required init?(coder aDecoder: NSCoder) {
            elements = aDecoder.decodeObject(forKey: "elements") as? [AdditionalCharge]
        }
        public required init?(map: Map) {
            
        }
        public func mapping(map: Map) {
            elements <- map["elements"]
        }
    }
    
    @objc(CloverConnectorModelsExtensionsPaymentsAdditionalCharge) public class AdditionalCharge: NSObject, NSCoding, Mappable {
        public var amount:Int?
        public var type:AdditionalChargeType?
        public var id:String?
        public var rate:Int64?
        
        public func encode(with aCoder: NSCoder) {
            aCoder.encode(amount, forKey: "amount")
            aCoder.encode(type?.chargeTypeString, forKey: "type")
            aCoder.encode(id, forKey: "id")
            aCoder.encode(rate, forKey: "rate")
        }
        
        public required init?(coder aDecoder: NSCoder) {
            amount = aDecoder.decodeObject(forKey: "amount") as? Int
            if let chargeType = aDecoder.decodeObject(forKey: "type") as? String {
                type = AdditionalChargeType(rawValue: chargeType)
            }
            id = aDecoder.decodeObject(forKey: "id") as? String
            rate = aDecoder.decodeObject(forKey: "rate") as? Int64
        }
        
        public required init?(map: Map) {
            
        }
        
        public func mapping(map: Map) {
            amount <- map["amount"]
            type <- (map["type"], Message.additionalChargeTypeTransform)
            id <- map["id"]
            rate <- map["rate"]
        }
        
        /// Describes the type of additional charge
        /// Note: `interac` is deprecated. Use `interacV2` instead.
        public enum AdditionalChargeType {
            /// Additional charge type for Interac cards. Deprecated, use `interacV2` instead
            case interac
            
            /// Additional charge type for a credit surcharge
            case creditSurcharge
            
            /// Additional charge type for a convenience fee
            case convenienceFee
            
            /// Additional charge type for Interac cards.
            case interacV2
            
            /// Additional charge type. Holder for future types that are as of yet undefined. Anything passed to the init not matching the other defined types will fall to this type, and will be returned by `chargeTypeString` in raw string form as it was provided.
            case other(String)
            
            /// Helper to create an enum based on a provided string; primarily useful for parsing string-based messages. Anything not matching an explicit case will be stored as `.other(String)`.
            /// - Parameter chargeType: String representation of the additional charge type
            init(rawValue: String) {
                switch rawValue {
                case "INTERAC":
                    self = .interac
                case "CREDIT_SURCHARGE":
                    self = .creditSurcharge
                case "CONVENIENCE_FEE":
                    self = .convenienceFee
                case "INTERAC_V2":
                    self = .interacV2
                default:
                    self = .other(rawValue)
                }
            }
            
            /// Returns the string representation of the enum value
            var chargeTypeString: String {
                switch self {
                case .interac:
                    return "INTERAC"
                case .creditSurcharge:
                    return "CREDIT_SURCHARGE"
                case .convenienceFee:
                    return "CONVENIENCE_FEE"
                case .interacV2:
                    return "INTERAC_V2"
                case .other(let rawValue):
                    return rawValue
                }
            }
        }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments7Payment)public class Payment: NSObject, NSCoding, Mappable {
        /// Unique identifier
        public var id: String?
        
        /// The order with which the payment is associated
        public var order: CLVModels.Base.Reference?
        
        /// Device which processed the transaction for this payment
        public var device: CLVModels.Base.Reference?
        
        /// The tender type associated with this payment, e.g. credit card, cash, etc.
        public var tender: CLVModels.Base.Tender?
        
        /// Total amount paid
        public var amount: Int?
        
        /// Amount paid in tips
        public var tipAmount: Int?
        
        /// Amount paid in tax
        public var taxAmount: Int?
        
        /// Amount given back in a cash back transaction
        public var cashbackAmount: Int?
        
        /// Amount of cash given by the customer
        public var cashTendered: Int?
        
        public var externalPaymentId: String?
        
        /// The employee who processed the payment
        public var employee: CLVModels.Base.Reference?
        
        /// Time payment was recorded on server
        public var createdTime: Date?
        
        public var clientCreatedTime: Date?
        
        /// Last modified time of the payment
        public var modifiedTime: Date?
        
        public var offline: Bool?
        
        public var result: CLVModels.Payments.Result? = nil
        
        /// Information about the card used for credit/debit card payments
        public var cardTransaction: CLVModels.Payments.CardTransaction?
        
        /// Amount record as a service charge
        public var serviceCharge: CLVModels.Payments.ServiceChargeAmount?
        
        public var taxRates: [CLVModels.Payments.PaymentTaxRate]?
        
        public var refunds: [CLVModels.Payments.Refund]?
        
        public var note: String?
        
        public var lineItemPayments: [CLVModels.Payments.LineItemPayment]?
        
        /// If voided, the reason why (when available)
        public var voidReason: CLVModels.Order.VoidReason? = nil
        
        /// Dynamic Currency Conversion information
        public var dccInfo: CLVModels.Payments.DCCInfo?
        
        /// Per transaction settings for the payment
        public var transactionSettings: CLVModels.Payments.TransactionSettings?
        
        /// German region-specific information
        public var germanInfo: CLVModels.Payments.GermanInfo?
        
        /// Tracking information for the app that created this payment.
        public var appTracking: CLVModels.Apps.AppTracking?
        
        /// Additional charges associated with this transaction (Canada INTERAC)
        public var additionalCharges: CLVModels.Payments.AdditionalCharges?
        
        public var transactionInfo: CLVModels.Payments.TransactionInfo?
        
        public var increments: [CLVModels.Payments.IncrementalAuthorization]?
        
        public func encode(with aCoder: NSCoder) {
            aCoder.encode(id, forKey: "id")
            aCoder.encode(order, forKey: "order")
            aCoder.encode(device, forKey: "device")
            aCoder.encode(tender, forKey: "tender")
            aCoder.encode(amount, forKey: "amount")
            aCoder.encode(tipAmount, forKey: "tipAmount")
            aCoder.encode(taxAmount, forKey: "taxAmount")
            aCoder.encode(cashbackAmount, forKey: "cashbackAmount")
            aCoder.encode(cashTendered, forKey: "cashTendered")
            aCoder.encode(externalPaymentId, forKey: "externalPaymentId")
            aCoder.encode(employee, forKey: "employee")
            aCoder.encode(createdTime, forKey: "createdTime")
            aCoder.encode(clientCreatedTime, forKey: "clientCreatedTime")
            aCoder.encode(modifiedTime, forKey: "modifiedTime")
            aCoder.encode(offline, forKey: "offline")
            aCoder.encode(result?.rawValue, forKey: "result")
            aCoder.encode(cardTransaction, forKey: "cardTransaction")
            aCoder.encode(serviceCharge, forKey: "serviceCharge")
            aCoder.encode(taxRates, forKey: "taxRates")
            aCoder.encode(refunds, forKey: "refunds")
            aCoder.encode(note, forKey: "note")
            aCoder.encode(lineItemPayments, forKey: "lineItemPayments")
            aCoder.encode(voidReason?.rawValue, forKey: "voidReason")
            aCoder.encode(dccInfo, forKey: "dccInfo")
            aCoder.encode(transactionSettings, forKey: "transactionSettings")
            aCoder.encode(germanInfo, forKey: "germanInfo")
            aCoder.encode(appTracking, forKey: "appTracking")
            aCoder.encode(additionalCharges, forKey: "additionalCharges")
            aCoder.encode(transactionInfo, forKey: "transactionInfo")
            aCoder.encode(increments, forKey: "increments")
        }
        
        required public init(coder aDecoder: NSCoder) {
            id = aDecoder.decodeObject(forKey: "id") as? String
            order = aDecoder.decodeObject(forKey: "order") as? CLVModels.Base.Reference
            device = aDecoder.decodeObject(forKey: "device") as? CLVModels.Base.Reference
            tender = aDecoder.decodeObject(forKey: "tender") as? CLVModels.Base.Tender
            amount = aDecoder.decodeObject(forKey: "amount") as? Int
            tipAmount = aDecoder.decodeObject(forKey: "tipAmount") as? Int
            taxAmount = aDecoder.decodeObject(forKey: "taxAmount") as? Int
            cashbackAmount = aDecoder.decodeObject(forKey: "cashbackAmount") as? Int
            cashTendered = aDecoder.decodeObject(forKey: "cashTendered") as? Int
            externalPaymentId = aDecoder.decodeObject(forKey: "externalPaymentId") as? String
            employee = aDecoder.decodeObject(forKey: "employee") as? CLVModels.Base.Reference
            createdTime = aDecoder.decodeObject(forKey: "createdTime") as? Date
            clientCreatedTime = aDecoder.decodeObject(forKey: "clientCreatedTime") as? Date
            modifiedTime = aDecoder.decodeObject(forKey: "modifiedTime") as? Date
            offline = aDecoder.decodeObject(forKey: "offline") as? Bool
            if let resultString = aDecoder.decodeObject(forKey: "result") as? String {
                result = CLVModels.Payments.Result(rawValue: resultString)
            }
            cardTransaction = aDecoder.decodeObject(forKey: "cardTransaction") as? CLVModels.Payments.CardTransaction
            serviceCharge = aDecoder.decodeObject(forKey: "serviceCharge") as? CLVModels.Payments.ServiceChargeAmount
            taxRates = aDecoder.decodeObject(forKey: "taxRates") as? [CLVModels.Payments.PaymentTaxRate]
            refunds = aDecoder.decodeObject(forKey: "refunds") as? [CLVModels.Payments.Refund]
            note = aDecoder.decodeObject(forKey: "note") as? String
            lineItemPayments = aDecoder.decodeObject(forKey: "lineItemPayments") as? [CLVModels.Payments.LineItemPayment]
            if let voidReasonString = aDecoder.decodeObject(forKey: "voidReason") as? String {
                voidReason = CLVModels.Order.VoidReason(rawValue: voidReasonString)
            }
            dccInfo = aDecoder.decodeObject(forKey: "dccInfo") as? CLVModels.Payments.DCCInfo
            transactionSettings = aDecoder.decodeObject(forKey: "transactionSettings") as? CLVModels.Payments.TransactionSettings
            germanInfo = aDecoder.decodeObject(forKey: "germanInfo") as? CLVModels.Payments.GermanInfo
            appTracking = aDecoder.decodeObject(forKey: "appTracking") as? CLVModels.Apps.AppTracking
            additionalCharges = aDecoder.decodeObject(forKey: "additionalCharges") as? AdditionalCharges
            transactionInfo = aDecoder.decodeObject(forKey: "transactionInfo") as? CLVModels.Payments.TransactionInfo
            increments = aDecoder.decodeObject(forKey: "increments") as? [CLVModels.Payments.IncrementalAuthorization]
        }
        
        override public init() {}
        
        // Mappable
        
        required public init?(map:Map) {}
        
        public func mapping(map:Map) {
            id <- map["id"]
            order <- map["order"]
            device <- map["device"]
            tender <- map["tender"]
            amount <- map["amount"]
            tipAmount <- map["tipAmount"]
            taxAmount <- map["taxAmount"]
            cashbackAmount <- map["cashbackAmount"]
            cashTendered <- map["cashTendered"]
            externalPaymentId <- map["externalPaymentId"]
            employee <- map["employee"]
            createdTime <- (map["createdTime"], CLVDateTransform())
            clientCreatedTime <- (map["clientCreatedTime"], CLVDateTransform())
            modifiedTime <- (map["modifiedTime"], CLVDateTransform())
            offline <- map["offline"]
            result <- map["result"]
            cardTransaction <- map["cardTransaction"]
            serviceCharge <- map["serviceCharge"]
            taxRates <- map["taxRates.elements"]
            refunds <- map["refunds.elements"]
            note <- map["note"]
            lineItemPayments <- map["lineItemPayments.elements"]
            voidReason <- map["voidReason"]
            dccInfo <- map["dccInfo"]
            transactionSettings <- map["transactionSettings"]
            germanInfo <- map["germanInfo"]
            appTracking <- map["appTracking"]
            additionalCharges <- map["additionalCharges"]
            transactionInfo <- map["transactionInfo"]
            increments <- map["increments.elements"]
        }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments15PaymentResponse)public class PaymentResponse: NSObject, NSCoding, Mappable {
      public var requestSuccessful: Bool?
      public var responseErrorMessage: String?
      public var payment: CLVModels.Payments.Payment?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(requestSuccessful, forKey: "requestSuccessful")
        aCoder.encode(responseErrorMessage, forKey: "responseErrorMessage")
        aCoder.encode(payment, forKey: "payment")
      }
      
      required public init(coder aDecoder: NSCoder) {
        requestSuccessful = aDecoder.decodeObject(forKey: "requestSuccessful") as? Bool
        responseErrorMessage = aDecoder.decodeObject(forKey: "responseErrorMessage") as? String
        payment = aDecoder.decodeObject(forKey: "payment") as? CLVModels.Payments.Payment
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        requestSuccessful <- map["requestSuccessful"]
        responseErrorMessage <- map["responseErrorMessage"]
        payment <- map["payment"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments14PaymentTaxRate)public class PaymentTaxRate: NSObject, NSCoding, Mappable {
      public var id: String?
      /// The payment with which the payment tax rate is associated
      public var paymentRef: CLVModels.Payments.Payment?
      public var name: String?
      public var rate: Int?
      public var isDefault: Bool?
      public var taxableAmount: Int?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(id, forKey: "id")
        aCoder.encode(paymentRef, forKey: "paymentRef")
        aCoder.encode(name, forKey: "name")
        aCoder.encode(rate, forKey: "rate")
        aCoder.encode(isDefault, forKey: "isDefault")
        aCoder.encode(taxableAmount, forKey: "taxableAmount")
      }
      
      required public init(coder aDecoder: NSCoder) {
        id = aDecoder.decodeObject(forKey: "id") as? String
        paymentRef = aDecoder.decodeObject(forKey: "paymentRef") as? CLVModels.Payments.Payment
        name = aDecoder.decodeObject(forKey: "name") as? String
        rate = aDecoder.decodeObject(forKey: "rate") as? Int
        isDefault = aDecoder.decodeObject(forKey: "isDefault") as? Bool
        taxableAmount = aDecoder.decodeObject(forKey: "taxableAmount") as? Int
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        id <- map["id"]
        paymentRef <- map["paymentRef"]
        name <- map["name"]
        rate <- map["rate"]
        isDefault <- map["isDefault"]
        taxableAmount <- map["taxableAmount"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments6Refund)public class Refund: NSObject, NSCoding, Mappable {
        /// Unique identifier
        public var id: String?
        /// The order with which the refund is associated
        public var orderRef: CLVModels.Order.Order?
        /// Device which processed the transaction for this refund
        public var device: CLVModels.Device.Device?
        /// Total amount refunded, including tax
        public var amount: Int?
        /// Tax amount refunded
        public var taxAmount: Int?
        /// Tip amount refunded
        public var tipAmount: Int?
        /// The time when the refund was recorded on the server
        public var createdTime: Date?
        /// The time when the refund was recorded on the client
        public var clientCreatedTime: Date?
        /// The payment with which the refund is associated
        public var payment: CLVModels.Payments.Payment?
        public var employee: CLVModels.Employees.Employee?
        public var lineItems: [CLVModels.Order.LineItem]?
        /// The tender type associated with this payment, e.g. credit card, cash, etc.
        public var overrideMerchantTender: CLVModels.Base.Tender?
        public var taxableAmountRates: [CLVModels.Payments.TaxableAmountRate]?
        public var serviceChargeAmount: CLVModels.Payments.ServiceChargeAmount?
        public var additionalCharges: [CLVModels.Payments.AdditionalCharge]?
        /// German region-specific information
        public var germanInfo: CLVModels.Payments.GermanInfo?
        /// Tracking information for the app that created this refund
        public var appTracking: CLVModels.Apps.AppTracking?
        public var voided: Bool?
        public var voidReason: String?
        /// Information about the card used for credit or debit card refunds
        public var cardTransaction: CLVModels.Payments.CardTransaction?
        public var transactionInfo: CLVModels.Payments.TransactionInfo?
        public var merchant: CLVModels.Base.Reference?
        /// The external reference id if associated with the refund
        public var externalReferenceId: String?
        
        public func encode(with aCoder: NSCoder) {
            aCoder.encode(id, forKey: "id")
            aCoder.encode(orderRef, forKey: "orderRef")
            aCoder.encode(device, forKey: "device")
            aCoder.encode(amount, forKey: "amount")
            aCoder.encode(taxAmount, forKey: "taxAmount")
            aCoder.encode(tipAmount, forKey: "tipAmount")
            aCoder.encode(createdTime, forKey: "createdTime")
            aCoder.encode(clientCreatedTime, forKey: "clientCreatedTime")
            aCoder.encode(payment, forKey: "payment")
            aCoder.encode(employee, forKey: "employee")
            aCoder.encode(lineItems, forKey: "lineItems")
            aCoder.encode(overrideMerchantTender, forKey: "overrideMerchantTender")
            aCoder.encode(taxableAmountRates, forKey: "taxableAmountRates")
            aCoder.encode(serviceChargeAmount, forKey: "serviceChargeAmount")
            aCoder.encode(additionalCharges, forKey: "additionalCharges")
            aCoder.encode(germanInfo, forKey: "germanInfo")
            aCoder.encode(appTracking, forKey: "appTracking")
            aCoder.encode(voided, forKey: "voided")
            aCoder.encode(voidReason, forKey: "voidReason")
            aCoder.encode(cardTransaction, forKey: "cardTransaction")
            aCoder.encode(transactionInfo, forKey: "transactionInfo")
            aCoder.encode(merchant, forKey: "merchant")
            aCoder.encode(externalReferenceId, forKey: "externalReferenceId")
        }
        
        required public init(coder aDecoder: NSCoder) {
            id = aDecoder.decodeObject(forKey: "id") as? String
            orderRef = aDecoder.decodeObject(forKey: "orderRef") as? CLVModels.Order.Order
            device = aDecoder.decodeObject(forKey: "device") as? CLVModels.Device.Device
            amount = aDecoder.decodeObject(forKey: "amount") as? Int
            taxAmount = aDecoder.decodeObject(forKey: "taxAmount") as? Int
            tipAmount = aDecoder.decodeObject(forKey: "tipAmount") as? Int
            createdTime = aDecoder.decodeObject(forKey: "createdTime") as? Date
            clientCreatedTime = aDecoder.decodeObject(forKey: "clientCreatedTime") as? Date
            payment = aDecoder.decodeObject(forKey: "payment") as? CLVModels.Payments.Payment
            employee = aDecoder.decodeObject(forKey: "employee") as? CLVModels.Employees.Employee
            lineItems = aDecoder.decodeObject(forKey: "lineItems") as? [CLVModels.Order.LineItem]
            overrideMerchantTender = aDecoder.decodeObject(forKey: "overrideMerchantTender") as? CLVModels.Base.Tender
            taxableAmountRates = aDecoder.decodeObject(forKey: "taxableAmountRates") as? [CLVModels.Payments.TaxableAmountRate]
            serviceChargeAmount = aDecoder.decodeObject(forKey: "serviceChargeAmount") as? CLVModels.Payments.ServiceChargeAmount
            additionalCharges = aDecoder.decodeObject(forKey: "additionalCharges") as? [CLVModels.Payments.AdditionalCharge]
            germanInfo = aDecoder.decodeObject(forKey: "germanInfo") as? CLVModels.Payments.GermanInfo
            appTracking = aDecoder.decodeObject(forKey: "appTracking") as? CLVModels.Apps.AppTracking
            voided = aDecoder.decodeObject(forKey: "voided") as? Bool
            voidReason = aDecoder.decodeObject(forKey: "voidReason") as? String
            cardTransaction = aDecoder.decodeObject(forKey: "cardTransaction") as? CLVModels.Payments.CardTransaction
            transactionInfo = aDecoder.decodeObject(forKey: "transactionInfo") as? CLVModels.Payments.TransactionInfo
            merchant = aDecoder.decodeObject(forKey: "merchant") as? CLVModels.Base.Reference
            externalReferenceId = aDecoder.decodeObject(forKey: "externalReferenceId") as? String
        }
        
        override public init() {}
        
        // Mappable
        
        required public init?(map:Map) {}
        
        public func mapping(map:Map) {
            id <- map["id"]
            orderRef <- map["orderRef"]
            device <- map["device"]
            amount <- map["amount"]
            taxAmount <- map["taxAmount"]
            tipAmount <- map["tipAmount"]
            createdTime <- (map["createdTime"], CLVDateTransform())
            clientCreatedTime <- (map["clientCreatedTime"], CLVDateTransform())
            payment <- map["payment"]
            employee <- map["employee"]
            lineItems <- map["lineItems.elements"]
            overrideMerchantTender <- map["overrideMerchantTender"]
            taxableAmountRates <- map["taxableAmountRates.elements"]            
            serviceChargeAmount <- map["serviceChargeAmount"]
            additionalCharges <- map["additionalCharges"]
            germanInfo <- map["germanInfo"]
            appTracking <- map["appTracking"]
            voided <- map["voided"]
            voidReason <- map["voidReason"]
            cardTransaction <- map["cardTransaction"]
            transactionInfo <- map["transactionInfo"]
            merchant <- map["transactionInfo"]
            externalReferenceId <- map["externalReferenceId"]
        }
    }
    
    public enum Result: String {
      case SUCCESS
      case FAIL
      case INITIATED
      case VOIDED
      case VOIDING
      case AUTH
      case AUTH_COMPLETED
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments16ServerTotalStats)public class ServerTotalStats: NSObject, NSCoding, Mappable {
      /// Employee corresponding to these stats
      public var employeeId: String?
      public var employeeName: String?
      public var sales: CLVModels.Payments.BatchTotalType?
      public var refunds: CLVModels.Payments.BatchTotalType?
      public var net: CLVModels.Payments.BatchTotalType?
      public var giftCardLoads: CLVModels.Payments.BatchTotalType?
      public var giftCardCashOuts: CLVModels.Payments.BatchTotalType?
      public var tax: CLVModels.Payments.BatchTotalType?
      public var tips: CLVModels.Payments.BatchTotalType?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(employeeId, forKey: "employeeId")
        aCoder.encode(employeeName, forKey: "employeeName")
        aCoder.encode(sales, forKey: "sales")
        aCoder.encode(refunds, forKey: "refunds")
        aCoder.encode(net, forKey: "net")
        aCoder.encode(giftCardLoads, forKey: "giftCardLoads")
        aCoder.encode(giftCardCashOuts, forKey: "giftCardCashOuts")
        aCoder.encode(tax, forKey: "tax")
        aCoder.encode(tips, forKey: "tips")
      }
      
      required public init(coder aDecoder: NSCoder) {
        employeeId = aDecoder.decodeObject(forKey: "employeeId") as? String
        employeeName = aDecoder.decodeObject(forKey: "employeeName") as? String
        sales = aDecoder.decodeObject(forKey: "sales") as? CLVModels.Payments.BatchTotalType
        refunds = aDecoder.decodeObject(forKey: "refunds") as? CLVModels.Payments.BatchTotalType
        net = aDecoder.decodeObject(forKey: "net") as? CLVModels.Payments.BatchTotalType
        giftCardLoads = aDecoder.decodeObject(forKey: "giftCardLoads") as? CLVModels.Payments.BatchTotalType
        giftCardCashOuts = aDecoder.decodeObject(forKey: "giftCardCashOuts") as? CLVModels.Payments.BatchTotalType
        tax = aDecoder.decodeObject(forKey: "tax") as? CLVModels.Payments.BatchTotalType
        tips = aDecoder.decodeObject(forKey: "tips") as? CLVModels.Payments.BatchTotalType
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        employeeId <- map["employeeId"]
        employeeName <- map["employeeName"]
        sales <- map["sales"]
        refunds <- map["refunds"]
        net <- map["net"]
        giftCardLoads <- map["giftCardLoads"]
        giftCardCashOuts <- map["giftCardCashOuts"]
        tax <- map["tax"]
        tips <- map["tips"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments19ServiceChargeAmount)public class ServiceChargeAmount: NSObject, NSCoding, Mappable {
      public var id: String?
      public var name: String?
      public var amount: Int?
      /// The payment with which the payment tax rate is associated
      public var paymentRef: CLVModels.Payments.Payment?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(id, forKey: "id")
        aCoder.encode(name, forKey: "name")
        aCoder.encode(amount, forKey: "amount")
        aCoder.encode(paymentRef, forKey: "paymentRef")
      }
      
      required public init(coder aDecoder: NSCoder) {
        id = aDecoder.decodeObject(forKey: "id") as? String
        name = aDecoder.decodeObject(forKey: "name") as? String
        amount = aDecoder.decodeObject(forKey: "amount") as? Int
        paymentRef = aDecoder.decodeObject(forKey: "paymentRef") as? CLVModels.Payments.Payment
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        id <- map["id"]
        name <- map["name"]
        amount <- map["amount"]
        paymentRef <- map["paymentRef"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments17TaxableAmountRate)public class TaxableAmountRate: NSObject, NSCoding, Mappable {
      public var id: String?
      public var name: String?
      public var taxableAmount: Int?
      public var rate: Int?
      public var isVat: Bool?
      public var taxAmount: Int?
      public var transactionRef: CLVModels.Base.Reference?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(id, forKey: "id")
        aCoder.encode(name, forKey: "name")
        aCoder.encode(taxableAmount, forKey: "taxableAmount")
        aCoder.encode(rate, forKey: "rate")
        aCoder.encode(isVat, forKey: "isVat")
        aCoder.encode(taxAmount, forKey: "taxAmount")
        aCoder.encode(transactionRef, forKey: "transactionRef")
      }
      
      required public init(coder aDecoder: NSCoder) {
        id = aDecoder.decodeObject(forKey: "id") as? String
        name = aDecoder.decodeObject(forKey: "name") as? String
        taxableAmount = aDecoder.decodeObject(forKey: "taxableAmount") as? Int
        rate = aDecoder.decodeObject(forKey: "rate") as? Int
        isVat = aDecoder.decodeObject(forKey: "isVat") as? Bool
        taxAmount = aDecoder.decodeObject(forKey: "taxAmount") as? Int
        transactionRef = aDecoder.decodeObject(forKey: "transactionRef") as? CLVModels.Base.Reference
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        id <- map["id"]
        name <- map["name"]
        taxableAmount <- map["taxableAmount"]
        rate <- map["rate"]
        isVat <- map["isVat"]
        taxAmount <- map["taxAmount"]
        transactionRef <- map["transactionRef"]
      }
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments11Transaction)public class Transaction: NSObject, NSCoding, Mappable {
      /// The time when the transaction was recorded on the server
      public var createdTime: Date?
      /// The time when the transaction was recorded on the client
      public var clientCreatedTime: Date?
      public var payment: CLVModels.Payments.Payment?
      public var refund: CLVModels.Payments.Refund?
      public var credit: CLVModels.Payments.Credit?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(createdTime, forKey: "createdTime")
        aCoder.encode(clientCreatedTime, forKey: "clientCreatedTime")
        aCoder.encode(payment, forKey: "payment")
        aCoder.encode(refund, forKey: "refund")
        aCoder.encode(credit, forKey: "credit")
      }
      
      required public init(coder aDecoder: NSCoder) {
        createdTime = aDecoder.decodeObject(forKey: "createdTime") as? Date
        clientCreatedTime = aDecoder.decodeObject(forKey: "clientCreatedTime") as? Date
        payment = aDecoder.decodeObject(forKey: "payment") as? CLVModels.Payments.Payment
        refund = aDecoder.decodeObject(forKey: "refund") as? CLVModels.Payments.Refund
        credit = aDecoder.decodeObject(forKey: "credit") as? CLVModels.Payments.Credit
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        createdTime <- (map["createdTime"], CLVDateTransform())
        clientCreatedTime <- (map["clientCreatedTime"], CLVDateTransform())
        payment <- map["payment"]
        refund <- map["refund"]
        credit <- map["credit"]
      }
    }
    
    
    
    public enum TxType: String {
      case AUTH
      case PREAUTH
      case PREAUTHCAPTURE
      case ADJUST
      case VOID
      case VOIDRETURN
      case RETURN
      case REFUND
      case NAKEDREFUND
      case GETBALANCE
      case BATCHCLOSE
      case ACTIVATE
      case BALANCE_LOCK
      case LOAD
      case CASHOUT
      case CASHOUT_ACTIVE_STATUS
      case REDEMPTION
      case REDEMPTION_UNLOCK
      case RELOAD
    }
    

    public enum TipMode: String {
        case TIP_PROVIDED
        case ON_SCREEN_BEFORE_PAYMENT
        case ON_SCREEN_AFTER_PAYMENT
        case ON_PAPER
        case NO_TIP
    }
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments19TransactionSettings)public class TransactionSettings: NSObject, NSCoding, Mappable {
        
        public var cardEntryMethods: Int?
        
        public var disableCashBack: Bool?
        
        public var cloverShouldHandleReceipts: Bool?
        
        public var forcePinEntryOnSwipe: Bool?
        
        public var disableRestartTransactionOnFailure: Bool?
        
        public var allowOfflinePayment: Bool?
        
        public var approveOfflinePaymentWithoutPrompt: Bool?
        
        public var signatureThreshold: Int?
        
        public var signatureEntryLocation: CLVModels.Payments.DataEntryLocation? = nil
        
        public var tipMode: CLVModels.Payments.TipMode? = nil
        
        public var tippableAmount: Int?
        
        public var tipSuggestions: [CLVModels.Merchant.TipSuggestion]?
        
        public var disableReceiptSelection: Bool?
        
        public var disableDuplicateCheck: Bool?
        
        public var autoAcceptPaymentConfirmations: Bool?
        
        public var autoAcceptSignature: Bool?
        
        public var forceOfflinePayment: Bool?
        
        public var disableCreditSurcharge: Bool?
        
        /// Any extra region specific data. Keys are referenced in RegionalExtras.swift
        public var regionalExtras: [String: String]?
        
        public func encode(with aCoder: NSCoder) {
            aCoder.encode(cardEntryMethods, forKey: "cardEntryMethods")
            aCoder.encode(disableCashBack, forKey: "disableCashBack")
            aCoder.encode(cloverShouldHandleReceipts, forKey: "cloverShouldHandleReceipts")
            aCoder.encode(forcePinEntryOnSwipe, forKey: "forcePinEntryOnSwipe")
            aCoder.encode(disableRestartTransactionOnFailure, forKey: "disableRestartTransactionOnFailure")
            aCoder.encode(allowOfflinePayment, forKey: "allowOfflinePayment")
            aCoder.encode(approveOfflinePaymentWithoutPrompt, forKey: "approveOfflinePaymentWithoutPrompt")
            aCoder.encode(signatureThreshold, forKey: "signatureThreshold")
            aCoder.encode(signatureEntryLocation?.rawValue, forKey: "signatureEntryLocation")
            aCoder.encode(tipMode?.rawValue, forKey: "tipMode")
            aCoder.encode(tippableAmount, forKey: "tippableAmount")
            aCoder.encode(tipSuggestions, forKey: "tipSuggestions")
            aCoder.encode(disableReceiptSelection, forKey: "disableReceiptSelection")
            aCoder.encode(disableDuplicateCheck, forKey: "disableDuplicateCheck")
            aCoder.encode(autoAcceptPaymentConfirmations, forKey: "autoAcceptPaymentConfirmations")
            aCoder.encode(autoAcceptSignature, forKey: "autoAcceptSignature")
            aCoder.encode(forceOfflinePayment, forKey: "forceOfflinePayment")
            aCoder.encode(regionalExtras, forKey: "regionalExtras")
        }
        
        required public init(coder aDecoder: NSCoder) {
            cardEntryMethods = aDecoder.decodeObject(forKey: "cardEntryMethods") as? Int
            disableCashBack = aDecoder.decodeObject(forKey: "disableCashBack") as? Bool
            cloverShouldHandleReceipts = aDecoder.decodeObject(forKey: "cloverShouldHandleReceipts") as? Bool
            forcePinEntryOnSwipe = aDecoder.decodeObject(forKey: "forcePinEntryOnSwipe") as? Bool
            disableRestartTransactionOnFailure = aDecoder.decodeObject(forKey: "disableRestartTransactionOnFailure") as? Bool
            allowOfflinePayment = aDecoder.decodeObject(forKey: "allowOfflinePayment") as? Bool
            approveOfflinePaymentWithoutPrompt = aDecoder.decodeObject(forKey: "approveOfflinePaymentWithoutPrompt") as? Bool
            signatureThreshold = aDecoder.decodeObject(forKey: "signatureThreshold") as? Int
            if let signatureEntryLocationString = aDecoder.decodeObject(forKey: "signatureEntryLocation") as? String {
                signatureEntryLocation = CLVModels.Payments.DataEntryLocation(rawValue: signatureEntryLocationString)
            }
            if let tipModeString = aDecoder.decodeObject(forKey: "tipMode") as? String {
                tipMode = CLVModels.Payments.TipMode(rawValue: tipModeString)
            }
            if let tipSuggestionArray = aDecoder.decodeObject(forKey: "tipSuggestions") as? [CLVModels.Merchant.TipSuggestion] {
                tipSuggestions = tipSuggestionArray
            }
            tippableAmount = aDecoder.decodeObject(forKey: "tippableAmount") as? Int
            disableReceiptSelection = aDecoder.decodeObject(forKey: "disableReceiptSelection") as? Bool
            disableDuplicateCheck = aDecoder.decodeObject(forKey: "disableDuplicateCheck") as? Bool
            autoAcceptPaymentConfirmations = aDecoder.decodeObject(forKey: "autoAcceptPaymentConfirmations") as? Bool
            autoAcceptSignature = aDecoder.decodeObject(forKey: "autoAcceptSignature") as? Bool
            forceOfflinePayment = aDecoder.decodeObject(forKey: "forceOfflinePayment") as? Bool
            regionalExtras = aDecoder.decodeObject(forKey: "regionalExtras") as? [String: String]
        }
        
        override public init() {}
        
        // Mappable
        required public init?(map:Map) {}
        
        public func mapping(map:Map) {
            cardEntryMethods <- map["cardEntryMethods"]
            disableCashBack <- map["disableCashBack"]
            cloverShouldHandleReceipts <- map["cloverShouldHandleReceipts"]
            forcePinEntryOnSwipe <- map["forcePinEntryOnSwipe"]
            disableRestartTransactionOnFailure <- map["disableRestartTransactionOnFailure"]
            allowOfflinePayment <- map["allowOfflinePayment"]
            approveOfflinePaymentWithoutPrompt <- map["approveOfflinePaymentWithoutPrompt"]
            signatureThreshold <- map["signatureThreshold"]
            signatureEntryLocation <- map["signatureEntryLocation"]
            tipMode <- map["tipMode"]
            tippableAmount <- map["tippableAmount"]
            tipSuggestions <- map["tipSuggestions.elements"]
            disableReceiptSelection <- map["disableReceiptSelection"]
            disableDuplicateCheck <- map["disableDuplicateCheck"]
            autoAcceptPaymentConfirmations <- map["autoAcceptPaymentConfirmations"]
            autoAcceptSignature <- map["autoAcceptSignature"]
            forceOfflinePayment <- map["forceOfflinePayment"]
            regionalExtras <- map["regionalExtras"]
        }
    }
    
    
    public enum Type_: String {
      case TAB
      case AUTH
    }
    
    
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments11VaultedCard)public class VaultedCard: NSObject, NSCoding, Mappable {
      public var first6: String?
      public var last4: String?
      public var cardholderName: String?
      public var expirationDate: String?
      public var token: String?
      
      public func encode(with aCoder: NSCoder) {
        aCoder.encode(first6, forKey: "first6")
        aCoder.encode(last4, forKey: "last4")
        aCoder.encode(cardholderName, forKey: "cardholderName")
        aCoder.encode(expirationDate, forKey: "expirationDate")
        aCoder.encode(token, forKey: "token")
      }
      
      required public init(coder aDecoder: NSCoder) {
        first6 = aDecoder.decodeObject(forKey: "first6") as? String
        last4 = aDecoder.decodeObject(forKey: "last4") as? String
        cardholderName = aDecoder.decodeObject(forKey: "cardholderName") as? String
        expirationDate = aDecoder.decodeObject(forKey: "expirationDate") as? String
        token = aDecoder.decodeObject(forKey: "token") as? String
      }
      
      override public init() {}
      
      // Mappable
      
      required public init?(map:Map) {}
      
      public func mapping(map:Map) {
        first6 <- map["first6"]
        last4 <- map["last4"]
        cardholderName <- map["cardholderName"]
        expirationDate <- map["expirationDate"]
        token <- map["token"]
      }
    }
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments8CardData)public class CardData:NSObject, NSCoding, Mappable {
        public var track1:String?
        public var track2:String?
        public var track3:String?
        public var encrypted:Bool?
        public var maskedTrack1:String?
        public var maskedTrack2:String?
        public var maskedTrack3:String?
        public var pan:String?
        public var cardholderName:String?
        public var firstName:String?
        public var lastName:String?
        public var exp:String?
        public var last4:String?
        public var first6:String?
        
        public func encode(with aCoder: NSCoder) {
            aCoder.encode(track1, forKey: "track1")
            aCoder.encode(track2, forKey: "track2")
            aCoder.encode(track3, forKey: "track3")
            aCoder.encode(encrypted, forKey: "encrypted")
            aCoder.encode(maskedTrack1, forKey: "maskedTrack1")
            aCoder.encode(maskedTrack2, forKey: "maskedTrack2")
            aCoder.encode(maskedTrack3, forKey: "maskedTrack3")
            aCoder.encode(pan, forKey: "pan")
            aCoder.encode(cardholderName, forKey: "cardholderName")
            aCoder.encode(firstName, forKey: "firstName")
            aCoder.encode(lastName, forKey: "lastName")
            aCoder.encode(exp, forKey: "exp")
            aCoder.encode(last4, forKey: "last4")
            aCoder.encode(first6, forKey: "first6")
            
        }
        
        required public init(coder aDecoder: NSCoder) {
            track1 = aDecoder.decodeObject(forKey: "track1") as? String
            track2 = aDecoder.decodeObject(forKey: "track2") as? String
            track3 = aDecoder.decodeObject(forKey: "track3") as? String
            encrypted = aDecoder.decodeObject(forKey: "encrypted") as? Bool
            maskedTrack1 = aDecoder.decodeObject(forKey: "maskedTrack1") as? String
            maskedTrack2 = aDecoder.decodeObject(forKey: "maskedTrack2") as? String
            maskedTrack3 = aDecoder.decodeObject(forKey: "maskedTrack3") as? String
            pan = aDecoder.decodeObject(forKey: "pan") as? String
            cardholderName = aDecoder.decodeObject(forKey: "cardholderName") as? String
            firstName = aDecoder.decodeObject(forKey: "firstName") as? String
            lastName = aDecoder.decodeObject(forKey: "lastName") as? String
            exp = aDecoder.decodeObject(forKey: "exp") as? String
            last4 = aDecoder.decodeObject(forKey: "last4") as? String
            first6 = aDecoder.decodeObject(forKey: "first6") as? String
        }
        
        override public init() {}
        
        required public init?(map:Map) {}
        
        public func mapping(map:Map) {
            track1 <- map["track1"]
            track2 <- map["track2"]
            track3 <- map["track3"]
            encrypted <- map["encrypted"]
            maskedTrack1 <- map["maskedTrack1"]
            maskedTrack2 <- map["maskedTrack2"]
            maskedTrack3 <- map["maskedTrack3"]
            pan <- map["pan"]
            cardholderName <- map["cardholderName"]
            firstName <- map["firstName"]
            lastName <- map["lastName"]
            exp <- map["exp"]
            last4 <- map["last4"]
            first6 <- map["first6"]
        }
    }
    
    @objc(_TtCCC15CloverConnector9CLVModels8Payments19PendingPaymentEntry)public class PendingPaymentEntry : NSObject, NSCoding, Mappable {
        public var paymentId:String?
        public var amount:Int?
        
        
        public func encode(with aCoder: NSCoder) {
            aCoder.encode(paymentId, forKey: "paymentId")
            aCoder.encode(amount, forKey: "amount")
        }
        
        required public init(coder aDecoder: NSCoder) {
            paymentId = aDecoder.decodeObject(forKey: "paymentId") as? String
            amount = aDecoder.decodeObject(forKey: "amount") as? Int
        }
        
        override public init() {}
        
        required public init?(map:Map) {}
        
        public func mapping(map:Map) {
            paymentId <- map["paymentId"]
            amount <- map["amount"]
        }
    }
    
    public class TransactionInfo: NSObject, Mappable {
        /// Two character language used for the transaction.  Deprecated in factor of transactionLocale.
        public var languageIndicator: String?
        /// Locale for the transaction (e.g. en-CA)
        public var transactionLocale: String?
        public var accountSelection: AccountType?
        /// Consists of 4 digits prefix + 8 digits
        public var fiscalInvoiceNumber: String?
        /// AR Installments: number of installments
        public var installmentsQuantity: Int32?
        /// AR Installments: plan alphanum code
        public var installmentsPlanCode: String?
        /// AR Installments: selected plan id
        public var installmentsPlanId: String?
        /// AR Installments: selected plan desc
        public var installmentsPlanDesc: String?
        /// Card type label
        public var cardTypeLabel: String?
        /// STAN(System Audit Trace Number)
        public var stan: Int32?
        /// Customers identification number and type
        public var identityDocument: IdentityDocument?
        /// Transaction Batch Number
        public var batchNumber: String?
        /// Transaction Receipt Number
        public var receiptNumber: String?
        /// STAN for reversal
        public var reversalStan: Int32?
        /// MAC for reversal
        public var reversalMac: String?
        /// MAC KSN for reversal
        public var reversalMacKsn: String?
        /// Designates the unique location of a terminal at a merchant
        public var terminalIdentification: String?
        /// When concatenated with the Acquirer Identifier, uniquely identifies a given merchant
        public var merchantIdentifier: String?
        /// Indicates the name and location of the merchant
        public var merchantNameLocation: String?
        /// Masked track2 data
        public var maskedTrack2: String?
        /// Extra data for receipt
        public var receiptExtraData: String?
        /// Defines the Financial Service selected for the transaction
        public var selectedService: SelectedService?
        /// Result of the transaction
        public var transactionResult: TransactionResult?
        /// Contains a hex string with needed TLV tags for certification
        public var transactionTags: String?
        /// Contains the information how the data inside transactionTags should be coded - initially we cause default and nexo as formats
        public var txFormat: TxFormat?
        /// Contains the reason why the transaction should be reversed in the host. It has to be mapped in server with the expected value by the corresponding gateway
        public var reversalReason: ReversalReason?
        /// Contains a hex string with the information how the PAN on cardholder receipts shall be masked
        public var panMask: String?
        /// Counter maintained by the terminal that is incremented for each transaction at the beginning of the Perform Service function
        public var transactionSequenceCounter: String?
        /// Identifies and differentiates cards with the same PAN
        public var applicationPanSequenceNumber: String?
        
        public required init?(map: Map) { }
        
        public func mapping(map: Map) {
            languageIndicator <- map["languageIndicator"]
            transactionLocale <- map["transactionLocale"]
            accountSelection <- map["accountSelection"]
            fiscalInvoiceNumber <- map["fiscalInvoiceNumber"]
            installmentsQuantity <- map["installmentsQuantity"]
            installmentsPlanCode <- map["installmentsPlanCode"]
            installmentsPlanId <- map["installmentsPlanId"]
            installmentsPlanDesc <- map["installmentsPlanDesc"]
            cardTypeLabel <- map["cardTypeLabel"]
            stan <- map["stan"]
            identityDocument <- map["identityDocument"]
            batchNumber <- map["batchNumber"]
            receiptNumber <- map["receiptNumber"]
            reversalStan <- map["reversalStan"]
            reversalMac <- map["reversalMac"]
            reversalMacKsn <- map["reversalMacKsn"]
            terminalIdentification <- map["terminalIdentification"]
            merchantIdentifier <- map["merchantIdentifier"]
            merchantNameLocation <- map["merchantNameLocation"]
            maskedTrack2 <- map["maskedTrack2"]
            receiptExtraData <- map["receiptExtraData"]
            selectedService <- map["selectedService"]
            transactionResult <- map["transactionResult"]
            transactionTags <- map["transactionTags"]
            txFormat <- map["txFormat"]
            reversalReason <- map["reversalReason"]
            panMask <- map["panMask"]
            transactionSequenceCounter <- map["transactionSequenceCounter"]
            applicationPanSequenceNumber <- map["applicationPanSequenceNumber"]
        }
    }
    
    public enum AccountType: String {
        case CREDIT
        case DEBIT
        case CHECKING
        case SAVINGS
    }
    
    public enum SelectedService: UInt8 {
        case none = 0x00
        case payment = 0x01
        case refund = 0x02
        case cancellation = 0x03
        case preAuth = 0x04
        case updatePreAuth = 0x05
        case paymentCompletion = 0x06
        case cashAdvance = 0x07
        case deferredPayment = 0x08
        case deferredPaymentCompletion = 0x09
        case voiceAuthorization = 0x10
        case cardholderDetection = 0x11
        
        // No NEXO-Services (default mode)
        case tokenRequest = 0x50
        case verification = 0x51
    }
    
    public enum TransactionResult: UInt8 {
        case approved = 0x00
        case declined = 0x01
        case aborted = 0x02
        case voiceAuthorization = 0x03
        case paymentPartOnly = 0x04
        case partiallyApproved = 0x05
        case none = 0x99
    }
    
    public enum TxFormat: String {
        case DEFAULT
        case NEXO
    }
    
    public enum ReversalReason: String {
        case CHIP_DECLINE
        case CARDHOLDER_CANCELLATION
        case COMMUNICATION_ERROR
        case OTHER_REASON
    }
    
    public class IdentityDocument: NSObject, Mappable {
        var type: String?
        var number: String?
        
        public required init?(map: Map) { }
        
        public func mapping(map: Map) {
            type <- map["type"]
            number <- map["number"]
        }
    }
  }
}
